<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng" type="xml"?>
<?oxygen SCHSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <title>Hello, Triangle!</title>
    <para>It is traditional for tutorials and introductory books on programming languages start with
        a program called <quote>Hello, World!</quote> This program is the simplest code necessary to
        print the text <quote>Hello, World!</quote> It serves as a good test to see that one's build
        system is functioning and that one can compile and execute code.</para>
    <para>Using OpenGL to write actual text is rather involved. In lieu of text, our first tutorial
        will be drawing a single triangle to the screen.</para>
    <section>
        <title>Framework and FreeGLUT</title>
        <para>The source to this tutorial, found in <filename>Tut1 Hello
                Triangle/tut1.cpp</filename>, is fairly simple. The project file that builds the
            final executable actually uses two source files: the tutorial file and a common
            framework file found in <filename>framework/framework.cpp</filename>. The framework file
            is where the actual initialization of FreeGLUT is done; it is also where main is. This
            file simply uses functions defined in the main tutorial file.</para>
        <para>FreeGLUT is a fairly simple OpenGL initialization system. It creates and manages a
            single window; all OpenGL commands refer to this window. Because windows in various GUI
            systems need to have certain book-keeping done, how the user interfaces with this is
            rigidly controlled.</para>
        <para>The framework file expects 4 functions to be defined: <function>init</function>,
                <function>display</function>, <function>reshape</function>, and
                <function>keyboard</function>. The <function>init</function> function is called
            after OpenGL is initialized. This gives the tutorial file the opportunity to load what
            it needs into OpenGL before actual rendering takes place. The
                <function>reshape</function> function is called by FreeGLUT whenever the window is
            resized. This allows the tutorial to make whatever OpenGL calls are necessary to keep
            the window's size in sync with OpenGL. The <function>keyboard</function> function is
            called by FreeGLUT whenever the user presses a key. This gives the tutorial the chance
            to process some basic user input.</para>
        <para>The <function>display</function> function is where the most important work happens.
            FreeGLUT will call this function when it detects that the screen needs to be rendered
            to.</para>
    </section>
    <section>
        <title>Dissecting Display</title>
        <para>The <function>display</function> function seems on the surface to be fairly simple.
            However, the functioning of it is fairly complicated and intertwined with the
            initialization done in the <function>init</function> function.</para>
        <example>
            <title>The <function>display</function> function</title>
            <programlisting>glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
glClear(GL_COLOR_BUFFER_BIT);

glUseProgram(theProgram);

glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
glEnableVertexAttribArray(positionAttrib);
glVertexAttribPointer(positionAttrib, 4, GL_FLOAT, GL_FALSE, 0, 0);

glDrawArrays(GL_TRIANGLES, 0, 3);

glDisableVertexAttribArray(positionAttrib);
glUseProgram(0);

glutSwapBuffers();</programlisting>
        </example>
        <para>Let us examine this code in detail.</para>
        <para>The first two lines clear the screen. <function>glClearColor</function> is one of
            those state setting functions; it sets the color to use when clearing the screen. It
            sets the clearing color to black. <function>glClear</function> does not set OpenGL
            state; it causes the screen to be cleared. The <literal>GL_COLOR_BUFFER_BIT</literal>
            parameter means that the clear call will affect the color buffer, causing it to be
            cleared to the current clearing color.</para>
        <para>The next line sets the current shader program to be used by all subsequent rendering
            commands. We will go into detail as to how this works later.</para>
        <para>The next three commands all set state. These command set up the coordinates of the
            triangle to be rendered. They tell OpenGL the location in memory that the positions of
            the triangle will come from. The specifics of how these work will be detailed
            later.</para>
        <para>The <function>glDrawArrays</function> function is, as the name suggests, a rendering
            function. It uses the current state to generate a stream of vertices that will form
            triangles.</para>
        <para>The next two lines are simply cleanup work, undoing some of the setup that was done
            for the purposes of rendering.</para>
        <para>The last line, <function>glutSwapBuffers</function>, is a FreeGLUT command, not an
            OpenGL command. The OpenGL framebuffer, as we set up in
                <filename>framework.cpp</filename>, is double-buffered. This means that the image
            that are currently being shown to the user is <emphasis>not</emphasis> the same image we
            are rendering to. Thus, all of our rendering is hidden from view until it is shown to
            the user. This way, the user never sees a half-rendered image.
                <function>glutSwapBuffers</function> is the function that causes the image we are
            rendering to be displayed to the user.</para>
    </section>
    <section>
        <title>Following the Pipeline</title>
        <para>In the <link linkend="core_graphics">basic background section</link>, we described the
            functioning of the OpenGL pipeline. We will now revisit this pipeline in the context of
            the code in tutorial 1. This will give us an understanding about the specifics of how
            OpenGL goes about things.</para>
        <section>
            <title>Vertex Transfer</title>
            <para>The first stage in the pipeline is transforming vertices to clip space. Before
                OpenGL can do this however, it must receive a list of vertices. So the very first
                stage of the pipeline is sending triangle data to OpenGL.</para>
            <para>This is the data that we wish to transfer:</para>
            <programlisting>const float vertexPositions[] = {
    0.75f, 0.75f, 0.0f, 1.0f,
    0.75f, -0.75f, 0.0f, 1.0f,
    -0.75f, -0.75f, 0.0f, 1.0f,
};</programlisting>
            <para>Each line of 4 values represents a 4D position of a vertex. These are four
                dimensional because, as you may recall, clip-space is 4D as well. These vertex
                positions are already in clip space. What we want OpenGL to do is render a triangle
                based on this vertex data. Since every 4 floats represents a vertex's position, we
                have 3 vertices: the minimum number for a triangle.</para>
            <para>Even though we have this data, OpenGL cannot use it directly. OpenGL has some
                limitations on what memory it can read from. You can allocate vertex data all you
                want yourself; OpenGL cannot directly see any of your memory. Therefore, the first
                step is to allocate some memory that OpenGL <emphasis>can</emphasis> see, and fill
                that memory with our data. This is done with something called a <glossterm>buffer
                    object.</glossterm></para>
            <para>A buffer object is a linear array of memory allocated by OpenGL at the behest of
                the user. This memory is controlled by the user, but the user has only indirect
                control over it. Think of a buffer object as an array of GPU memory. The GPU can
                read this memory quickly, so storing data in it has performance advantages.</para>
            <para>The buffer object in the tutorial was created during initialization. Here is the
                code responsible for creating the buffer object:</para>
            <example>
                <title>Buffer Object Initialization</title>
                <programlisting>void InitializeVertexBuffer()
{
    glGenBuffers(1, &amp;positionBufferObject);
    
    glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertexPositions), vertexPositions, GL_STATIC_DRAW);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
}</programlisting>
            </example>
            <para>The first line creates the buffer object, storing the handle to the object in the
                global variable <varname>positionBufferObject</varname>. Though the object now
                exists, it doesn't own any memory yet. That is because we have not allocated any
                with this object.</para>
            <para>The <function>glBindBuffer</function> function makes the buffer object the
                currently bound buffer to the <literal>GL_ARRAY_BUFFER</literal> binding target. As
                mentioned in Tutorial 0, objects in OpenGL usually have to be bound to the context
                in order for them to do anything, and buffer objects are no exception.</para>
            <para>The <function>glBufferData</function> function allocates memory for the buffer
                currently bound to <literal>GL_ARRAY_BUFFER</literal>, which is the one we just
                created. We already have some vertex data; the problem is that it is in our memory
                rather than OpenGL's memory. This function allocates enough GPU memory to store our
                vertex data. The third parameter is a pointer to the data to initialize the buffer
                with; we give it our vertex data. The fourth parameter is something we will look at
                in future tutorials.</para>
            <para>The second bind buffer call is simply cleanup. By binding the buffer object 0 to
                    <literal>GL_ARRAY_BUFFER</literal>, we cause the buffer object previously bound
                to that target to become unbound from it. This was not strictly necessary, as any
                later binds to this target will simply unbind what is already there. But unless you
                have very strict control over your rendering, it is usually a good idea to unbind
                the objects you bind.</para>
            <para>This is all just to get the vertex data in the GPU's memory. But buffer objects
                are not formatted; as far as OpenGL is concerned, all we did was fill a buffer
                object with random binary data. We now need to do something that tells OpenGL that
                there is vertex data in this buffer object.</para>
            <para>We do this in the rendering code. That is the purpose of these lines:</para>
            <programlisting>glBindBuffer(GL_ARRAY_BUFFER, positionBufferObject);
glEnableVertexAttribArray(positionAttrib);
glVertexAttribPointer(positionAttrib, 4, GL_FLOAT, GL_FALSE, 0, 0);</programlisting>
            <para>The first function we have seen before. It simply says that we are going to use
                this buffer object.</para>
            <para>The second function, <function>glEnableVertexAttribArray</function> is something
                we will explain in the next section, when we talk about where
                    <varname>positionAttrib</varname> comes from. Suffice it to say that this
                function tells OpenGL that the vertex data called <varname>positionAttrib</varname>
                will be provided in rendering calls. Without this function, the next one is
                unimportant.</para>
            <para>The third function is the real key. <function>glVertexAttribPointer</function>,
                despite having the word <quote>Pointer</quote> in it, does not deal with pointers.
                Instead, it deals with buffer objects.</para>
            <para>This function tells OpenGL where a particular piece of vertex data is coming from.
                The buffer that is bound to GL_ARRAY_BUFFER at the time that this function is called
                is the buffer object that will be associated with this piece of data.</para>
            <para>What this particular function call is saying is this. <quote>The piece of vertex
                    data called <varname>positionAttrib</varname> comes from the buffer object
                        <varname>positionBufferObject</varname>. This piece of vertex data contains
                    32-bit float values, and each piece is a sequence of 4 of them. The data starts
                    at the 0th byte of the buffer object, and each set of 4 32-bit floats is tightly
                    packed together.</quote> This means that our data of 24 floats represents enough
                information for the 3 vertices of a single triangle; this is exactly what we
                want.</para>
            <para>The specifics of this function call will be discussed in later tutorials.</para>
            <para>Once OpenGL knows where to get its vertex data from, it can now use that vertex
                data to render.</para>
            <programlisting>glDrawArrays(GL_TRIANGLES, 0, 3);</programlisting>
            <para>This function seems very simple on the surface, but it does a great deal. The
                second and third parameters represent the start index and the number of indices to
                read from our vertex data. We start at the 0th index, and read 3 vertices from it.
                The first parameter tells OpenGL that it is to take every 3 vertices that it gets as
                an independent triangle. Thus, it will read 3 vertices and connect them to form a
                triangle.</para>
            <para>Again, we will go into details in another tutorial.</para>
        </section>
        <section>
            <title>Vertex Processing and Shaders</title>
            <para>Now that we can tell OpenGL what the vertex data is, we come to the next stage of
                the pipeline: vertex processing. This is one of two programmable stages that we will
                cover in this tutorial, so this involve the use of a
                <glossterm>shader.</glossterm></para>
            <para>All a shader is is a program that runs on the GPU. There are several possible
                shader stages in the pipeline, and each has its own inputs and outputs. The purpose
                of a shader is to take its inputs, as well as potentially various other data, and
                convert them into a set of outputs.</para>
            <para>Each shader is executed over a set of inputs. It is important to note that a
                shader, of any stage, operates <emphasis>completely independently</emphasis> of any
                other shader of that stage. There can be no crosstalk between separate executions of
                a shader. Execution for each set of inputs starts from the beginning of the shader
                and continues to the end. A shader defines what its inputs and outputs are, and it
                is illegal for a shader to complete without writing to all of its outputs.</para>
            <para>Vertex shaders, as the name implies, operate on vertices. Specifically, each
                invocation of a vertex shader operates on a <emphasis>single</emphasis> vertex.
                These shaders must output, among any other user-defined outputs, a clip-space
                position for that vertex. Where this comes from is up to the shader.</para>
            <para>Shaders in OpenGL are written in the OpenGL Shading Language
                    (<acronym>GLSL</acronym>). This language looks suspiciously like C, but it is
                very much not C. It has far too many limitations to be C (for example, recursion is
                forbidden). This is what our simple vertex shader looks like:</para>
            <example>
                <title>Vertex Shader</title>
                <programlisting>#version 150

in vec4 position;
void main()
{
    gl_Position = position;
}</programlisting>
            </example>
            <para>This looks fairly simple. The first line states that the version of GLSL used by
                this shader is version 1.50. A version declaration is required for all GLSL
                shaders.</para>
            <para>The next line defines an input to the vertex shader. The input is called
                    <varname>position</varname> and is of type <type>vec4</type>: a 4-dimensional
                vector of floating-point values.</para>
            <para>As with C, a shader's execution starts with the <function>main</function>
                function. This shader is very simple, copying the input <varname>position</varname>
                into something called <varname>gl_Position</varname>. This is a variable that is
                    <emphasis>not</emphasis> defined in the shader; that is because it is a standard
                variable defined by every vertex shader. If you see an identifier in GLSL that
                starts with <quote>gl_,</quote> then it must be a built-in identifier.</para>
            <para><varname>gl_Position</varname> is defined as:</para>
            <programlisting>out vec4 gl_Position;</programlisting>
            <para>Recall that the minimum a vertex shader must do is generate a clip-space position
                for the vertex. That is what <varname>gl_Position</varname> is: it is the output
                that represents a clip-space position.</para>
            <formalpara>
                <title>Vertex Attributes</title>
                <para>Inputs to and outputs from a shader stage come from somewhere and go to
                    somewhere. Thus, the input <varname>position</varname> must be filled in with
                    data somewhere. So where does that data come from? Inputs to a vertex shader are
                    called <glossterm>vertex attributes</glossterm>.</para>
            </formalpara>
            <para>You might recognize something similar to the term <quote>vertex attribute.</quote>
                For example, <quote>glEnable<emphasis>VertexAttrib</emphasis>Array</quote> or
                        <quote>gl<emphasis>VertexAttrib</emphasis>Pointer.</quote></para>
            <para>This is how data flows down the pipeline in OpenGL. When rendering starts, vertex
                data in a buffer object is read based on setup work done by
                    <varname>glVertexAttribPointer</varname>. This function describes where the data
                for an attribute comes from. The connection between a particular call to
                    <function>glVertexAttribPointer</function> and the string name of an input value
                to a vertex shader is somewhat complicated. This is where that mysterious variable,
                    <varname>positionAttrib,</varname> comes into play.</para>
            <para>The details of compiling a shader will be gone over a bit later, but the
                connection is made with this call:</para>
            <programlisting>positionAttrib = glGetAttribLocation(theProgram, "position");</programlisting>
            <para>The variable <varname>theProgram</varname> represents the vertex shader (and the
                fragment shader, but that's for later). The function
                    <function>glGetAttribLocation</function> takes the given string that specifies a
                vertex input, and it returns a number that represents that particular input. This
                number is then used in subsequent <function>glVertexAttribPointer</function> calls
                and the like to represent the attribute for <quote>position.</quote></para>
        </section>
        <section>
            <title>Rasterization</title>
            <para>All that has happened thus far is that 3 vertices have been given to OpenGL and it
                has transformed them with a vertex shader into 3 positions in clip-space. Next, the
                vertex positions are transformed into normalized-device coordinates by dividing the
                3 XYZ components of the position by the W component. In our case, W is always 1.0,
                so the positions are already effectively in normalized-device coordinates.</para>
            <para>After this, the vertex positions are transformed into window coordinates. Once in
                window coordinates, OpenGL can now take these 3 vertices and scan-convert it into a
                series of fragments. In order to do this however, OpenGL must decide what the list
                of vertices represents.</para>
            <para>OpenGL can interpret a list of vertices in a variety of different ways. The way
                OpenGL interprets vertex lists is given by the draw command:</para>
            <programlisting>glDrawArrays(GL_TRIANGLES, 0, 3);</programlisting>
            <para>The enum <literal>GL_TRIANGLES</literal> tells OpenGL that every 3 vertices of the
                list should be taken to be a triangle. Since we passed only 3 vertices, we get 1
                triangle.</para>
        </section>
        <section>
            <title>Fragment Processing</title>
            <para>A fragment shader is used to compute the output color(s) of a fragment. The inputs
                of a fragment shader include the window-space XYZ position of the fragment. It can
                also include user-defined data, but we will get to that.</para>
            <para>Our fragment shader looks like this:</para>
            <example>
                <title>Fragment Shader</title>
                <programlisting>#version 150

out vec4 outputColor;
void main()
{
   outputColor = vec4(1.0f, 1.0f, 1.0f, 1.0f);
}</programlisting>
            </example>
            <para>As with the vertex shader, the first line states that the shader uses GLSL version
                1.50.</para>
            <para>The next line specifies an output for the fragment shader. The output variable is
                of type <type>vec4</type>.</para>
            <para>The main function simply sets the output color to a 4-dimensional vector, with all
                of the components as 1.0f. This sets the Red, Green, and Blue components of the
                color to full intensity, which is 1.0; this creates the white color of the triangle.
                The fourth component is something we will see in later tutorials.</para>
            <para>This fragment shader does not do anything with the position input.</para>
            <para>After the fragment shader executes, the fragment output color is written to the
                output image.</para>
        </section>
    </section>
    <section>
        <title>Making Shaders</title>
        <para>We glossed over exactly how these text strings called shaders actually get used. We
            will go into some detail on that now.</para>
        <para/>
    </section>
    <section>
        <title>Conclusion</title>
        <para>At this point, you have a good general overview of how things work in OpenGL. You know
            how to compile and link shaders, how to pass some basic vertex data to OpenGL, and how
            to render a triangle.</para>
        <section>
            <title>Things to Try</title>
            <para>Feel free to modify the tutorial and try any of the following:</para>
            <itemizedlist>
                <listitem>
                    <para>Change the color value set by the fragment shader to different values. Use
                        values in the range [0, 1], and see what happens when you go outside that
                        range.</para>
                </listitem>
                <listitem>
                    <para>Change the positions of the vertex data. Keep position values in the [-1,
                        1] range, then see what happens when triangles go outside this range.</para>
                </listitem>
                <listitem>
                    <para/>
                </listitem>
            </itemizedlist>
        </section>
    </section>
</chapter>
