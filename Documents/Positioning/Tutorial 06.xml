<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng" type="xml"?>
<?oxygen SCHSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <?dbhtml filename="Tutorial 06.html" ?>
    <title>Objects in Motion</title>
    <para>In this tutorial, we will look at a number of ways to transform objects, rendering them in
        different locations and orientations in the world.</para>
    <section>
        <title>Spaces</title>
        <para>Throughout this series of tutorials, we have discussed a number of different spaces.
            We have seen OpenGL-defined spaces like normalized device coordinate (NDC) space,
            clip-space, and window space. And we have seen user-defined spaces like camera space.
            But we have yet to talk about what a space actually is.</para>
        <para>A <glossterm>space</glossterm> is a shorthand term for a <glossterm>coordinate
                system.</glossterm> For the purposes of this conversation, a coordinate system or
            space consists of the following:</para>
        <itemizedlist>
            <listitem>
                <para>The dimensionality of the space. 2D, 3D, 4D, etc.</para>
            </listitem>
            <listitem>
                <para>A series of vectors in those dimensions that define the axes of the space. The
                    directions do not have to be orthogonal (at right-angles) to one another, but
                    there must be one axis per dimension. Each axis vector in the space has a name,
                    like X, Y, Z, etc. These are called the <glossterm>basis vectors</glossterm> of
                    a space.</para>
            </listitem>
            <listitem>
                <para>A location in the space that defines the central <glossterm>origin</glossterm>
                    point. The origin is the point from which all other points in the space are
                    derived.</para>
            </listitem>
            <listitem>
                <para>An area within this space in which points are valid. Outside of this range,
                    positions are not valid. The range can be infinite depending on the
                    space.</para>
            </listitem>
        </itemizedlist>
        <para>A position or vertex in a space is defined as the sum of the axis vectors, where each
            basis vector is multiplied by a value called a coordinate. Any point in the space is
            thus defined by this equation:</para>
        <!--TODO: Show the vectoral equation defining a point.-->
        <para>The coordinate used to refer to a position depends entirely on the coordinate system
            being used to describe that position. For example, here are two positions that appear
            the same, from a neutral observer's point of view, that have completely different
            coordinates.</para>
        <!--TODO: Show a 2D orthogonal and 2D skewed coordinate system, and the same coordinate position from both.-->
        <para>This is all well and good when dealing with axis vectors and the origin point as
            generic vectors as drawn above. The origin point is just a position, and the basis
            vectors are simply drawn. But what does it mean to give actual numbers to these
            concepts? A position, like the origin point, is itself a coordinate. Which means that it
            must be defined relative to some coordinate system. The same goes for the basis
            vectors.</para>
        <para>For the purpose of this discussion, there is a coordinate system that acts as a kind
            of neutral coordinate system; it can be used as a generic viewpoint for a coordinate
            system. For a three-dimensional coordinate system, this identity space has the origin at
            (0, 0, 0), with the X, Y and Z axis vectors as (1, 0, 0), (0, 1, 0), and (0, 0, 1). The
            range of the space is infinite. Any space can be defined relative to this identity
            space. And unless otherwise noted, this is the space of any axis vectors or origin
            points.</para>
        <section>
            <title>Transformation</title>
            <para>In the more recent tutorials, the ones dealing with perspective projections, we
                have been taking positions in one coordinate system (space) and putting them in
                another coordinate system. Specifically, we had objects in camera space that we
                moved into clip space. The process of taking a coordinate in one space and
                specifying it as a coordinate in another space is called
                    <glossterm>transformation</glossterm>. The coordinate's actual meaning has not
                changed; all that has changed is the coordinate system that this coordinate is
                relative to.</para>
            <para>We have seen a number of coordinate system transformations. OpenGL implements the
                transformation from clip-space to NDC space, and the transformation from NDC to
                window space. Our shaders implement the transformation from camera space to
                clip-space, and this was done using a matrix. Perspective projection (and
                orthographic, for that matter) are simply a special kind of transformation.</para>
            <para>This tutorial will cover a large number of different kinds of transform
                operations, and how to implement them in OpenGL.</para>
        </section>
        <section>
            <title>Model Space</title>
            <para>Before we begin, we must define a new kind of space: <glossterm>model
                    space.</glossterm> This is a user-defined space; but unlike camera space, model
                space does not have a single definition. It is instead a catch-all term for the
                space that a particular object begins in. Coordinates in vertex buffers, passed to
                the vertex shaders as vertex attributes are <foreignphrase>de facto</foreignphrase>
                in model space.</para>
            <para>There are an infinite variety of model spaces. Each object one intends to render
                can, and often does, have its own model space, even if the difference between these
                spaces is only in the origin point. Model spaces for an object are generally defined
                for the convenience of the modeller or the programmer who intends to use that
                model.</para>
            <para>The transformation operation being discussed in this tutorial is the transform
                from model space to camera space. Our shaders already know how to handle
                camera-space data; all they need is a way to transform from model space to camera
                space.</para>
        </section>
    </section>
    <section>
        <?dbhtml filename="Tut06 Translation.html" ?>
        <title>Translation</title>
        <para>The simplest space transformation operation is translation. Indeed, we have not only
            seen this transform before, it has been used in all of the tutorials with a perspective
            projection. Remember this line from the vertex shaders:</para>
        <programlisting language="glsl">vec4 cameraPos = position + vec4(offset.x, offset.y, 0.0, 0.0);</programlisting>
        <para>This is a <glossterm>translation</glossterm> transformation: it is used to position
            the origin point of the initial space relative to the destination space. Since all of
            the coordinates in a space are relative to the origin point of that space, all a
            translation needs to do is add a vector to all of the coordinates in that space. The
            vector added tothese values is the location of where the user wants the origin point
            relative to the destination coordinate system.</para>
        <para>Here is a more concrete example. Let us say that an object which in its model space is
            near its origin. This means that, if we want to see that object in front of the camera,
            we must position the origin of the model in front of the camera. If the extent of the
            model is only [-1, 1] in model space, we can ensure that the object is visible by adding
            this vector to all of the model space coordinates: (0, 0, -3). This puts the origin of
            the model at that position in camera space.</para>
        <!--TODO: 2D diagram of this translation.-->
        <para>Translation is ultimately just that simple. So let's make it needlessly complex. And
            the best tool for doing that: matrices. Oh, we could just use a 3D uniform vector to
            pass an offset to do the transformation. But matrices have hidden benefits we will
            explore... soon.</para>
        <para>All of our position vectors are 4D vectors, with a final W coordinate that is always
            1.0. In <link linkend="Tut04_matrix">Tutorial 04,</link> we took advantage of this with
            our perspective transformation matrix. The equation for the Z coordinate needed an
            additive term, so we put that term in the W column of the transformation matrix. Matrix
            multiplication causes the value in the W column to be multiplied by the W coordinate of
            the vector (which is 1) and added to the sum of the other terms.</para>
        <para>But how do we keep the matrix from doing something to the other terms? We only want
            this matrix to apply an offset to the position. We don't want to have it modify the
            position in some other way.</para>
        <para>This is done by modifying an <glossterm>identity matrix.</glossterm> An identity
            matrix is a matrix that, when performing matrix multiplication, will return the original
            value. It is sort of like the number 1 with regular multiplication: 1*X = X. The 4x4
            identity matrix looks like this:</para>
        <!--TODO: An identity matrix.-->
        <para>To modify the identity matrix into one that is suitable for translation, we simply put
            the offset into the W column of the identity matrix.</para>
        <!--TODO: The translation matrix.-->
        <para>The tutorial project cleverly titled <phrase role="propername">Translation</phrase>
            performs translation operations.</para>
        <para>This tutorial renders 3 of the same object, all in different positions. One of the
            objects is positioned in the center of the screen, and the other two's positions orbit
            it at various speeds.</para>
        <para>Because of the prevalence of matrix math, this is the first tutorial that uses the GLM
            math library. So let's take a look at the shader program initialization code to see it
            in action.</para>
        <example>
            <title>Translation Shader Initialization</title>
            <programlisting language="cpp">void InitializeProgram()
{
    std::vector&lt;GLuint> shaderList;
    
    shaderList.push_back(Framework::LoadShader(GL_VERTEX_SHADER, "PosColorLocalTransform.vert"));
    shaderList.push_back(Framework::LoadShader(GL_FRAGMENT_SHADER, "ColorPassthrough.frag"));
    
    theProgram = Framework::CreateProgram(shaderList);
    
    positionAttrib = glGetAttribLocation(theProgram, "position");
    colorAttrib = glGetAttribLocation(theProgram, "color");
    
    modelToCameraMatrixUnif = glGetUniformLocation(theProgram, "modelToCameraMatrix");
    cameraToClipMatrixUnif = glGetUniformLocation(theProgram, "cameraToClipMatrix");
    
    float fzNear = 1.0f; float fzFar = 45.0f;
    
    cameraToClipMatrix[0].x = fFrustumScale;
    cameraToClipMatrix[1].y = fFrustumScale;
    cameraToClipMatrix[2].z = (fzFar + fzNear) / (fzNear - fzFar);
    cameraToClipMatrix[2].w = -1.0f;
    cameraToClipMatrix[3].z = (2 * fzFar * fzNear) / (fzNear - fzFar);
    
    glUseProgram(theProgram);
    glUniformMatrix4fv(cameraToClipMatrixUnif, 1, GL_FALSE, glm::value_ptr(cameraToClipMatrix));
    glUseProgram(0);
}</programlisting>
        </example>
        <para>GLM takes a unique approach, for a vector/matrix math library. It attempts to emulate
            GLSL's approach to vector operations where possible. It uses C++ operator overloading to
            effectively emulate GLSL. In most cases, GLM-based code would compile in GLSL.</para>
        <para>The matrix <varname>cameraToClipMatrix</varname> is defined as a
                <type>glm::mat4</type>, which has the same properties as a GLSL <type>mat4.</type>
            Array indexing of a <type>mat4</type>, whether GLM or GLSL, returns the zero-based
                <emphasis>column</emphasis> of the matrix as a <type>vec4</type>.</para>
        <para>The <function>glm::value_ptr</function> function is used to get a direct pointer to
            the matrix data, in column-major order. This is useful for uploading data to OpenGL, as
            shown with the call to <function>glUniformMatrix4fv</function>.</para>
        <para>With the exception of getting a second uniform location (for our model transformation
            matrix), this code functions exactly as it did in previous tutorials.</para>
        <para>There is one important note: <varname>fFrustumScale</varname> is not 1.0 anymore.
            Until now, the relative sizes of objects were not particularly meaningful. Now that we
            are starting to deal with more complex objects that have a particular scale, picking a
            proper field of view for the perspective projection is very important.</para>
        <para>The new <varname>fFrustumScale</varname> is computed with this code:</para>
        <example>
            <title>Frustum Scale Computation</title>
            <programlisting language="cpp">float CalcFrustumScale(float fFovDeg)
{
    const float degToRad = 3.14159f * 2.0f / 360.0f;
    float fFovRad = fFovDeg * degToRad;
    return 1.0f / tan(fFovRad / 2.0f);
}

const float fFrustumScale = CalcFrustumScale(45.0f);</programlisting>
        </example>
        <para>The function <function>CalcFrustumScale</function> computes the frustum scale based on
            a field-of-view angle in degrees. The field of view in this case is the angle between
            the forward direction and the direction of the farmost-extent of the view.</para>
        <para>This project, and many of the others in this tutorial, use a fairly complex bit of
            code to manage the transform matrices for the various object instances. There is an
                <classname>Instance</classname> object for each actual object; it has a function
            pointer that is used to compute the object's offset position. The
                <classname>Instance</classname> object then takes that position and computes a
            transformation matrix, based on the current elapsed time, with this function:</para>
        <example>
            <title>Translation Matrix Generation</title>
            <programlisting language="cpp">glm::mat4 ConstructMatrix(float fElapsedTime)
{
    glm::mat4 theMat(1.0f);
    
    theMat[3] = glm::vec4(CalcOffset(fElapsedTime), 1.0f);
    
    return theMat;
}</programlisting>
        </example>
        <para>The <type>glm::mat4</type> constructor that takes only a single value constructs what
            is known as a diagonal matrix. That is a matrix with all zeros except for along the
            diagonal from the upper-left to the lower-right. The values along that diagonal will be
            the value passed to the constructor. An identity matrix is just a diagonal matrix with 1
            as the value along the diagonal.</para>
        <para>This function simply replaces the W column of the matrix with the offset value.</para>
        <para>This all produces the following:</para>
        <figure>
            <title>Translation Project</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Translations.png"/>
                </imageobject>
            </mediaobject>
        </figure>
    </section>
    <section>
        <?dbhtml filename="Tut06 Scale.html" ?>
        <title>Scale</title>
        <para>Another kind of transformation is <glossterm>scaling</glossterm>. In terms of our
            previous definition of a coordinate system, this means that our axis vectors are getting
            shorter or longer.</para>
        <!--TODO: show a 2D scaling transform.-->
        <para>Scaling can be uniform, which means each axis vector is scaled by the same value. A
            non-uniform scale means that each axis can get a different scale, or none at all.</para>
        <para>Uniform scales are used to allow objects in model space to have different units from
            the units used in camera space. For example, a modeller may have generated the model in
            inches, but the world uses centimeters. This will require applying a uniform scale to
            all of these models to compensate for this. This scale should be 2.54, which is the
            conversion factor from inches to centimeters.</para>
        <para>Note that scaling always happens relative to the origin of the space being
            scaled.</para>
        <para>Remember how we defined the way coordinate systems generate a position, based on the
            axis vectors and origin point?</para>
        <!--TODO: the vector equation from before-->
        <para>If you are increasing or decreasing the length of the axis vectors, this is the same
            as multiplying those axis vectors by the new length. So we can re-express this equation
            as follows:</para>
        <!--TODO: scaled version of vector equation-->
        <para>Since multiplication is both associative and commutative, we can multiply the scales
            directly into the coordinates to achieve the same effect. So a scaled space can be
            reexpressed as simply multiplying the coordinate values.</para>
        <para>This is easy enough to do in GLSL, if you pass a vector uniform containing the scale
            values. But how do we express this as a matrix?</para>
        <para>This gets a bit technical, in terms of how a matrix multiplication works. But look
            back at the identity matrix:</para>
        <!--TODO: identity matrix again.-->
        <para>This matrix selects each coordinate in turn from the vector it is being multiplied
            into. Each row is multiplied with the column of the vector; all of the zeros remove the
            components of the vector that we do not want. The one multiplies into the component we
            do want, thus selecting it. This produces the identity result: the vector we started
            with.</para>
        <para>We can see that, if the ones were some other value, we would get a scaled version of
            the original vector, depending on which ones were changed. Thus, a scaling
            transformation matrix looks like this:</para>
        <!--TODO: scaling transform matrix.-->
        <para>You may start to see a pattern emerging here, something that begins to suggest why
            matrices are very, very useful. I won't spoil it for you yet though.</para>
        <para>The tutorial project <phrase role="propername">Scale</phrase> will display 5 objects
            at various scales. The objects are all at the same Z distance from the camera, so the
            only size difference between the objects is the scale effects applied to them. The
            object in the center is unscaled; each of the other objects has a scale function of some
            kind applied to them.</para>
        <figure>
            <title>Scale Project</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Scales.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Other than the way the tutorial builds its matrices, there is no difference between
            this tutorial project and the previous one. The matrix building code works as
            follows:</para>
        <programlisting language="cpp">glm::mat4 ConstructMatrix(float fElapsedTime)
{
    glm::vec3 theScale = CalcScale(fElapsedTime);
    glm::mat4 theMat(1.0f);
    theMat[0].x = theScale.x;
    theMat[1].y = theScale.y;
    theMat[2].z = theScale.z;
    theMat[3] = glm::vec4(offset, 1.0f);
    
    return theMat;
}</programlisting>
        <para>As before, the scale is supplied by a number of scale functions, depending on which
            instance is being rendered. The scale is stored in the columns of the identity matrix.
            Then the translation portion of the matrix is filled in.</para>
        <para>The <varname>offset</varname> variable is also a member of the
                <classname>Instance</classname> object. Unlike the last tutorial, the offset is a
            fixed value. We will discuss the ramifications of applying multiple transforms later;
            suffice it to say, this currently works.</para>
        <para>Scaling is only slightly more complicated than translation.</para>
        <section>
            <title>Perspective and Scaling</title>
            <para>The way we construct a scale transformation matrix may seem familiar to you. Back
                in Tutorial 4, the perspective transformation involved a frustum scale value. This
                was used to make up for the fact that our projection defined a specific location for
                the plane of projection and camera eye point. Using this frustum scale, we could
                give the appearance of having a larger or smaller viewing size. Indeed, we later
                used this to define the aspect ratio as well as the field of view, using the
                function defined earlier in this tutorial.</para>
            <para>This frustum scale was ultimately nothing more than a scale factor applied the X
                and Y positions. When we constructed the perspective matrix, we used the frustum
                scale as a uniform scaling in the X and Y dimensions. The aspect ratio compensation
                code was nothing more than applying a <emphasis>non</emphasis>uniform scale.</para>
        </section>
        <section>
            <title>Inversion and Winding Order</title>
            <para>Scales can be theoretically negative, or even 0. A scale of 0 causes the axis
                vector in that direction to become 0 entirely. An axis vector with no length means
                that a dimension has effectively been lost. The resulting transform squashes
                everthing in that direction down to the origin. A 3D space becomes a 2D space (or 1D
                or 0D, depending on how many axes were scaled).</para>
            <para>A negative scale changes the direction of an axis. This causes vertices
                transformed with this scale to flip across the origin in that axis's direction. This
                is called an <glossterm>inversion</glossterm>. This can have certain unintended
                consequences. In particular, it can change the winding order of vertices.</para>
            <para>Back in <link linkend="tut04_face_culling">Tutorial 4</link>, we introduced the
                ability to cull triangles based on the order in which the vertices appeared in
                window space. Depending on which axis you negate, relative to camera space, an
                inversion can flip the expected winding order of vertices. Thus, triangles that
                were, in model space, forward-facing now in camera space are backwards-facing. And
                vice-versa.</para>
            <para>Negative scaling can have other problems as well. This is not to say that
                inversions cannot be used, but they should be used with care.</para>
        </section>
    </section>
    <section>
        <?dbhtml filename="Tut06 Rotation.html" ?>
        <title>Rotation</title>
        <para>A <glossterm>rotation</glossterm> transformation is the result of the orientation of
            the initial space being different from the orientation of the destination space. The
            axis vectors of the space do not changed relative to one another, but relative to the
            destination coordinate system, they are pointed in different directions than they were
            in their own coordinate system.</para>
        <para>A rotation looks like this:</para>
        <!--TODO: Show a rotation transformation-->
        <para>Rotations are usually considered the most complex of transformations, primarily
            because of the math involved in computing the transformation matrix. Generally,
            rotations are looked at as an operation, such as rotating around a particular axis or
            some such. The prior part of the tutorial laid down some of the groundwork that will
            make this much simpler.</para>
        <para>First, let's look back at our equation for determining what the position of a
            coordinate is relative to certain coordinate space:</para>
        <!--TODO: Show the vector equation again-->
        <para>Doesn't this look a bit familiar? No? Perhaps an alternate look at vector-matrix
            multiplication would help:</para>
        <!--TODO: Show a matrix multiplication.-->
        <para>Does it look familiar <emphasis>now</emphasis>?</para>
        <para>What this tells us is that the columns of our transformation matrices are, and have
            always been, nothing more than the axes of a coordinate system. Except for the fourth
            column: because the position has a 1 in the W, it acts as an offset.</para>
        <para>Transformation ultimately means this: taking the axis vectors and origin point from
            the original coordinate system and re-expressing them relative to the destination
            coordinate system.</para>
        <para>Therefore, if a rotation is just using a different set of axis directions, then
            building a rotation transformation matrix simply requires computing a new set of axes
            that different directions, but have the same length as the original ones. Now, this is
            not easy; it requires semi-advanced math (which is easily encapsulated into various
            functions). But no matter how complex the math may be, this math is nothing more than a
            way to compute axis vectors that point in different directions.</para>
        <para>That is, a rotation matrix is not really a rotation matrix; it is an
                <emphasis>orientation</emphasis> matrix. It defines the orientation of a space
            relative to another space. Remember this, and you will avoid many pitfalls when you
            start dealing with more complex transformations.</para>
        <para>For any two spaces, the orientation transformation between then can be expressed as
            rotating the source space by some angle around a particular axis (also in the initial
            space). This is true for any change of orientation.</para>
        <para>A common rotation question is to compute a rotation around an arbitrary axis. Or more
            correctly, to determine the orientation of a space if it is rotated around an arbitrary
            axis relative to the initial axis. The axis of rotation is expressed in terms of the
            initial space. In 2D, there is only one axis that can be rotated around and still remain
            within that 2D plane: the Z-axis.</para>
        <!--TODO: show rotation transform.-->
        <para>In 3D, there are many possible axes of rotation. It does not have to be one of the
            initial space's basis axes; it can be any arbitrary direction. Of course, the problem is
            made much simpler if one rotates only around the primary axes.</para>
        <para>Deriving these matrix equations is beyond the scope of this tutorial; so instead, we
            will simply provide them. To perform rotations along the primary axes, use the following
            matrices:</para>
        <!--TODO: show the 3 main rotation matrices.-->
        <para>When using the C library <function>sin</function> and <function>cos</function>
            functions, the angles must be in radians.</para>
        <para>As useful as these are, the more generic equation for rotation by an angle about an
            arbitrary axis is as follows.</para>
        <!--TODO: Show the angle/axis rotation function.-->
        <para>All of these matrices are such that, from the point of view of an observer looking
            down the axis of rotation (the direction of the axis is pointed into the eye of the
            observer), the object rotates counter-clockwise.</para>
        <para>The <phrase role="propername">Rotations</phrase> tutorial shows off each of these
            rotation matrix functions. Similar to how the others work, there are multiple instances
            rendered based on functions.</para>
        <figure>
            <title>Rotation Project</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Rotations.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>The function that builds the transformation matrix looks like this:</para>
        <example>
            <title>Rotation Transformation Building</title>
            <programlisting language="cpp">glm::mat4 ConstructMatrix(float fElapsedTime)
{
    const glm::mat3 &amp;rotMatrix = CalcRotation(fElapsedTime);
    glm::mat4 theMat(rotMatrix);
    theMat[3] = glm::vec4(offset, 1.0f);
    
    return theMat;
}</programlisting>
        </example>
        <para>The constructor of glm::mat4 that takes a glm::mat3 generates a 4x4 matrix with the
            3x3 matrix in the top-left corner, and all other positions 0 except the bottom-left
            corner, which is set to 1. As with the rest of GLM, this works in GLSL as well.</para>
    </section>
    <section>
        <?dbhtml filename="Tut06 Successive Transformations.html" ?>
        <title>Successive Transformations</title>
        <para>In all of the previous examples except for the translation one, we always combined the
            transformation with a translation operation. So the scale transform was not a pure scale
            transform; it was a scale and translate transformation matrix. The translation was there
            primarily so that we could see everything properly.</para>
        <para>But these are not the only combinations of transformations that can be performed.
            Indeed, any combination of transformation operations is possible, though it may not be
                <emphasis>meaningful.</emphasis></para>
        <para>Successive transformations can be seen as doing successive multiplication operations.
            For example, if S is a pure scale matrix, T is a pure translation matrix, and R is a
            pure scale matrix, then one can easily do the following in a shader:</para>
        <programlisting language="glsl">vec4 temp;
temp = T * position;
temp = R * temp;
temp = S * temp;
gl_Position = cameraToClipMatrix * temp;</programlisting>
        <para>In mathematical terms, this would be the following series of matrix operations: <inlineequation>
                <mathphrase>Final = C*S*R*T*position</mathphrase>
            </inlineequation>, where C is the camera-to-clip space transformation matrix.</para>
        <!--TODO: show an equation with the various terms.-->
        <para>This is functional, but not particularly flexible; the series of transforms is baked
            into the shader. It is also not particularly fast, what with having to do four matrix
            multiplications, per vertex.</para>
        <para>Matrix math gives us an optimization. Matrix math is not commutative: <inlineequation>
                <mathphrase>S*R</mathphrase>
            </inlineequation> is not the same as <inlineequation>
                <mathphrase>R*S</mathphrase>
            </inlineequation>. However, it <emphasis>is</emphasis> associative: <inlineequation>
                <mathphrase>(S*R)*T</mathphrase>
            </inlineequation> is the same as <inlineequation>
                <mathphrase>S*(R*T)</mathphrase>
            </inlineequation>. The usual grouping for vertex transformation is this: <inlineequation>
                <mathphrase>Final = C*(S*(R*(T*position)))</mathphrase>
            </inlineequation>. But this can easily be regrouped as: <inlineequation>
                <mathphrase>Final = (((C*S)*R)*T)*position</mathphrase>
            </inlineequation>.</para>
        <para>This would in fact be slower for the shader to compute, since full matrix-to-matrix
            multiplication is much slower than matrix-to-vector multiplication. But the combined
            matrix <inlineequation>
                <mathphrase>(((C*S)*R)*T)</mathphrase>
            </inlineequation> is <emphasis>fixed</emphasis> for all of a given object's vertices.
            This can be computed on the CPU, and all we have to do is upload a single matrix to
            OpenGL. And since we're already uploading a matrix to OpenGL for each object we render,
            this changes nothing about the overall performance characteristics of the
            rendering.</para>
        <para><emphasis>This</emphasis> is one of the main reasons matrices are used. You can have a
            transformation sequence with dozens of component transformations, and yet all it takes
            for the GPU to process this is a single vector/matrix multiplication.</para>
        <section>
            <title>Order of Transforms</title>
            <para>As previously stated, matrix multiplication is not commutative. This means that
                the combined transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> is not the same as <inlineequation>
                    <mathphrase>T*S</mathphrase>
                </inlineequation>. Let us explore this further. This is what these two composite
                transform matrices look like:</para>
            <!--TODO: Show T, S, S*T and T*S.-->
            <para>The transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> actually scales the translation part of the resulting matrix. This
                means that the vertices will not just get farther from each other, but farther
                    <emphasis>from the origin</emphasis> of the destination space. It is the
                difference between these two transforms:</para>
            <!--TODO: Show what the two transforms actually look like.-->
            <para>If you think about the order of operations, this makes sense. Even though one can
                think of the combined transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> as a single transform, it is ultimately a composite operation. The
                transformation T happens first; the object is translated into a new position.</para>
            <para>What you must understand is that something special happens between S and T.
                Namely, that S is now being applied to positions that are not from model space (the
                space the original vertices were in), but are in <emphasis>post translation
                    space.</emphasis> This is an intermediate coordinate system defined by T.
                Remember: a matrix, even a translation matrix, defines a full-fledged coordinate
                system.</para>
            <para>So S now acts on the T-space position of the vertices. T-space has an origin,
                defined by the matrix T. A scaling transformation matrix performs scaling based on
                the origin point in the space of the vertices being scaled. So the scaling matrix S
                will scale the points away from the origin point in T-space. Since what you
                (probably) actually wanted was to scale the points away from the origin point in
                    <emphasis>model space</emphasis>, S needs to come first.</para>
            <para>Rotation (orientation) matrices have the same issue. The orientation is always
                local to the origin in the current space of the positions. So a rotation matrix must
                happen before the translation matrix. Scales generally should happen before
                orientation; if they happen afterwards, then the scale will be relative to the
                    <emphasis>new</emphasis> axis orientation, not the model-space one. This is fine
                if it is a uniform scale, but a non-uniform scale will be problematic.</para>
            <para>There are reasons to put a translation matrix first. If the model-space origin is
                not the point that you wish to rotate or scale around, then you will need to perform
                the translation first, then apply a scale or rotation. Doing this multiple times can
                allow you to scale and rotate about two completely different points. However, this
                gets progressively more difficult, as each new translation needs to be based on the
                space of the rotated or scaled points.</para>
        </section>
        <section>
            <title>Transformation Spaces</title>
            <para>Our scaling transform is interesting, but it does have certain flaws. The most
                important problem is that it causes a scale based on the X, Y and Z axes of the
                initial coordinate system. So what do you do if you want to scale something along
                different axes?</para>
            <para>This is quite simple, really: you use successive transforms. First, you transform
                into a space where the <quote>different axes</quote>
                <emphasis>are</emphasis> the X, Y and Z axes. Then you do your scaling transform.
                After that, you transform back to the original space.</para>
            <para>If the different axes represent an orientation change, you can use a rotation
                matrix. Simply rotate, apply the scale, and rotate back. The last part is done by
                generating the rotation matrix using the same axis, but negating the angle.</para>
            <para>Transforming into a space that is convenient for another transform, applying that
                transform, and then undoing the first transform is a general-purpose operation. The
                matrix that results from this is a transformation in a different space. In the
                scaling case, we want to do the scaling in a different space, so we apply a rotation
                matrix to get into that space, then undo the rotation after applying the
                scale.</para>
            <para>The general form of this sequence is as follows. Suppose you have a transformation
                T, that you wish to apply in the space M. The transformation matrix T in the space
                of M is <inlineequation>
                    <mathphrase>M<superscript>-1</superscript>TM</mathphrase>
                </inlineequation>.</para>
            <para>The matrix M<superscript>-1</superscript> is the <glossterm>inverse
                    matrix</glossterm> of M. The symbol <superscript>-1</superscript> does not
                (strictly) mean to raise the matrix to the -1 power. It simply means to invert
                it.</para>
            <para>The inverse matrix of M is the matrix N such that <inlineequation>
                    <mathphrase>MN = I</mathphrase>
                </inlineequation>, where I is the identity matrix. This can be analogized to the
                scalar multiplicative inverse (ie: reciprocal). The scalar multiplicative inverse of
                X is the number Y such that <inlineequation>
                    <mathphrase>XY = 1</mathphrase>
                </inlineequation>.</para>
            <para>In the case of the scalar inverse, this is very easy to compute: <inlineequation>
                    <mathphrase>Y = 1/X</mathphrase>
                </inlineequation>. However, even in this case, there are values of X for which there
                is no multiplicative inverse. Well, one value of X: 0.</para>
            <para>The case of the inverse matrix is much more complicated. Just as with the scalar
                inverse, there are matrices that have no inverse. Unlike the scalar case, there are
                a <emphasis>lot</emphasis> of matrices with no inverse. Also, computing the inverse
                matrix is a <emphasis>lot</emphasis> more complicated than simply taking the
                reciprocal of a value.</para>
            <para>Most common transformation matrices <emphasis>do</emphasis> have an inverse. And
                for the simplest of matrices, the inverse matrix is very easy to compute. For a pure
                rotation matrix, simply compute a new rotation matrix by negating the angle that the
                old one was generated with. For a translation matrix, negate the origin value in the
                matrix. For a scale matrix, take the reciprocal of the scale along each axis.</para>
            <para>To take the inverse of a sequence of matrices, you can take the inverse of each of
                the component matrices. But you have to do the matrix multiplication in
                    <emphasis>reverse</emphasis> order. So the inverse matrix for the sequence <inlineequation>
                    <mathphrase>TRS</mathphrase>
                </inlineequation> is <inlineequation>
                    <mathphrase>S<superscript>-1</superscript>R<superscript>-1</superscript>T<superscript>-1</superscript></mathphrase>
                </inlineequation>.</para>
        </section>
        <section>
            <title>Hierarchical Models</title>
            <para>In more complex scenes, it is often desireable to specify the transform of one
                model relative to the model space transform of another model. This is useful if you
                want one object (object B) to pick up another object (object A). The object that
                gets picked up needs to follow the transform of the object that picked it up. So it
                is often easiest to specify the transform for object B relative to object A.</para>
            <para>A conceptually single model that is composed of multiple transforms for multiple
                rendered objects is called a <glossterm>hierarchical model.</glossterm> In such a
                hierarchy, the final transform for any of the component pieces is a sequence of all
                of the transforms of its parent transform, plus its own model space transform.
                Models in this transform have a parent-child relationship to other objects.</para>
            <para>For the purposes of this discussion, each complete transform for a model in the
                hierarchy call be called a <glossterm>node.</glossterm> Each node is defined by a
                specific series of transformations, which when combined yield the complete
                transformation matrix for that node. Usually, each node has a translation, rotation,
                and scale, though the specific transform can be entirely arbitrary. What matters is
                that the full transformation matrix is relative to the space of its parent, not
                camera space.</para>
            <para>So if you have a node who's translation is (3, 0, 4), then it will be 3 X-units
                and 4 Z-units from the origin of its parent transform. The node itself doesn't know
                or care what the parent transform actually is; it simply stores a transform relative
                to that.</para>
            <para>Technically, a node does not have to have a mesh. It is sometimes useful in a
                hierarchical model to have nodes that exist solely to position other, visible nodes.
                Or to act as key points for other purposes, such as identifying the position of the
                gun's muzzle to render a muzzle flash.</para>
            <para>The <phrase role="propername">Hierarchy</phrase> tutorial renders a hierarchical
                model of an arm. This tutorial is interactive; the relative angles of the nodes can
                be changed with keyboard commands. The angles are bound within certain values, so
                the model will stop bending once these values are exceeded. These commands are as
                follows:</para>
            <table frame="none">
                <title>Hierarchy Tutorial Key Commands</title>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Node Angle</entry>
                            <entry>Increase/Left</entry>
                            <entry>Decrease/Right</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Base Spin</entry>
                            <entry><keycap>a</keycap></entry>
                            <entry><keycap>d</keycap></entry>
                        </row>
                        <row>
                            <entry>Arm Raise</entry>
                            <entry><keycap>w</keycap></entry>
                            <entry><keycap>s</keycap></entry>
                        </row>
                        <row>
                            <entry>Elbow Raise</entry>
                            <entry><keycap>r</keycap></entry>
                            <entry><keycap>f</keycap></entry>
                        </row>
                        <row>
                            <entry>Wrist Raise</entry>
                            <entry><keycap>t</keycap></entry>
                            <entry><keycap>g</keycap></entry>
                        </row>
                        <row>
                            <entry>Wrist Spin</entry>
                            <entry><keycap>z</keycap></entry>
                            <entry><keycap>c</keycap></entry>
                        </row>
                        <row>
                            <entry>Finger Open/Close</entry>
                            <entry><keycap>q</keycap></entry>
                            <entry><keycap>e</keycap></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <figure>
                <title>Hierarchy Project</title>
                <mediaobject>
                    <imageobject>
                        <imagedata fileref="Robot%20Arm.png"/>
                    </imageobject>
                </mediaobject>
            </figure>
            <para>The structure of the tutorial is very interesting and shows off a number of
                important data structures for doing this kind of rendering.</para>
            <para>The class <classname>Hierarchy</classname> stores the information for our
                hierarchy of nodes. It stores the relative positions for each node, as well as angle
                information and size information for the size of each rectangle. The rendering code
                in <function>display</function> simply does the usual setup work and calls
                    <function>Hierarchy::Draw()</function>, where the real work happens.</para>
            <para>The <function>Draw</function> function looks like this:</para>
            <example>
                <title>Hierarchy::Draw</title>
                <programlisting language="cpp">void Draw()
{
    MatrixStack modelToCameraStack;
    
    glUseProgram(theProgram);
    glBindVertexArray(vao);
    
    modelToCameraStack.Translate(posBase);
    modelToCameraStack.RotateY(angBase);
    
    //Draw left base.
    {
        modelToCameraStack.Push();
        modelToCameraStack.Translate(posBaseLeft);
        modelToCameraStack.Scale(glm::vec3(1.0f, 1.0f, scaleBaseZ));
        glUniformMatrix4fv(modelToCameraMatrixUnif, 1, GL_FALSE, glm::value_ptr(modelToCameraStack.Top()));
        glDrawElements(GL_TRIANGLES, ARRAY_COUNT(indexData), GL_UNSIGNED_SHORT, 0);
        modelToCameraStack.Pop();
    }
    
    //Draw right base.
    {
        modelToCameraStack.Push();
        modelToCameraStack.Translate(posBaseRight);
        modelToCameraStack.Scale(glm::vec3(1.0f, 1.0f, scaleBaseZ));
        glUniformMatrix4fv(modelToCameraMatrixUnif, 1, GL_FALSE, glm::value_ptr(modelToCameraStack.Top()));
        glDrawElements(GL_TRIANGLES, ARRAY_COUNT(indexData), GL_UNSIGNED_SHORT, 0);
        modelToCameraStack.Pop();
    }
    
    //Draw main arm.
    DrawUpperArm(modelToCameraStack);
    
    glBindVertexArray(0);
    glUseProgram(0);
}</programlisting>
            </example>
            <para>The program and VAO binding code should look familiar, but most of the code should
                be fairly foreign.</para>
            <para>The <classname>MatrixStack</classname> object created in the very first line is a
                class that is also a part of this project. It implements the concept of a
                    <glossterm>matrix stack.</glossterm> The matrix stack is a method for dealing
                with transformations in hierarchical models.</para>
            <para>A stack is a particular data structure concept. Stacks store a controlled sequence
                of objects. But unlike arrays, linked lists, or other general data structures, there
                are only 3 operations available to the user of a stack: push, pop, and peek. Push
                places a value on the top of the stack. Pop removes the value on the top of the
                stack, making the previous top the current top. And peek simply returns the current
                value at the top of the stack.</para>
            <para>A matrix stack is, for the most part, a stack where the values are 4x4
                transformation matrices. Matrix stacks do have a few differences from regular
                stacks. C++ has an object, <classname>std::stack</classname>, that implements the
                stack concept. <classname>MatrixStack</classname> is a wrapper around that object,
                providing additional matrix stack functionality.</para>
            <para>A matrix stack has a current matrix value. An initially constructed matrix stack
                has an identity matrix. There are a number of functions on the matrix stack that
                multiply the current matrix by a particular transformation matrix; the result
                becomes the new current matrix. For example, the
                    <classname>MatrixStack::RotateX</classname> function multiplies the current
                matrix by a rotation around the X axis by the given angle.</para>
            <para>The <function>MatrixStack::Push</function> function takes the current matrix and
                pushes it onto the stack. The <function>MatrixStack::Pop</function> function makes
                the current matrix whatever the top of the stack is, and removes the top from the
                stack. The effect of these is to allow you to save a matrix, modify the current
                matrix, and then restore the old one after you have finished using the modified one.
                And you can store an arbitrary number of matrices, all in a specific order. This is
                invaluable when dealing with a hierarchical model, as it allows you to iterate over
                each element in the model from root to the leaf nodes, preserving older transforms
                and recovering them as needed.</para>
            <para>In the <function>Draw</function> code, the translation is applied to the stack
                first, followed by an X rotation based on the current angle. Note that the order of
                operations is <emphasis>backwards</emphasis> from what we said previously. That's
                because the matrix stack looks at transforms backwards. When we said earlier that
                the rotation should be applied before the translation, that was with respect to the
                    <emphasis>position</emphasis>. That is, the equation should be <inlineequation>
                    <mathphrase>T*R*v</mathphrase>
                </inlineequation>, where v is the position. What we meant was that R should be
                applied to v before T. This means that R comes to the right of T.</para>
            <para>Rather than applying matrices to vertices, we are applying matrices to each other.
                The matrix stack functions all perform right-multiplication; the new matrix being
                multiplied by the current is on the right side. The matrix stack starts with the
                identity matrix. To have it store T*R, you must first apply the T transform (the
                current matrix is I*T) then apply the R transform, making the current matrix
                I*T*R.</para>
            <para>Right-multiplication is necessary, as the whole point of using the matrix stack is
                so that we can start at the root of a hierarchical model and save each node's
                transform to the stack as we go from parent to child. That simply would not be
                possible if matrix stacks left-multiplied, since we would have to apply the child
                transforms before the parent ones.</para>
            <para>The next thing that happens is that the matrix is preserved by pushing it on the
                stack. After this, a translation and scale are applied to the matrix stack. The
                stack's current matrix is uploaded to the program, and a model is rendered. Then the
                matrix stack is popped, restoring the original transform. What is the purpose of
                this code?</para>
            <para>This code effectively introduces a new kind of space. It was not strictly
                necessary for this example, but it does show off a commonly used technique. The new
                space here does not have a widely agreed upon name, the way other user-defined
                spaces like model space and camera space do. For the purposes of these tutorials,
                let us call this <glossterm>mesh space.</glossterm></para>
            <para>Notice that, for the individual nodes of hierarchical models, model space (the
                node's transform) is propagated to all of the children. The T*R matrix we generated
                was the model space matrix for the base of the model; this transform is preserved on
                the matrix stack and passed to the child drawing functions. However, sometimes it is
                useful to use source mesh data where the mesh itself is <emphasis>not</emphasis> in
                model space.</para>
            <para>In our case, we do this because we know that all of our pieces are 3D rectangles.
                A 3D rectangle is really just a cube with scales and translations applied to them.
                The scale makes the cube into the proper size, and the translation positions the
                origin point for our model space.</para>
            <para>Rather than have this mesh space transform, we could have created 9 or so actual
                rectangle meshes, one for each rendered rectangle. However, this would have required
                more buffer object room and more vertex attribute changes when these were simply
                unnecessary. The vertex shader runs no slower this way; it's still just multiplying
                by matrices. And the minor CPU computation time is exactly that: minor.</para>
            <para>Mesh space is very useful, even though it isn't commonly talked about to the point
                where it gets a special name. As we have seen, it allows easy model reusage, but it
                has other properties as well. For example, it can be good for data compression. As
                we will see in later tutorials, there are ways to store values on the range [0, 1]
                or [-1, 1] in 16 or 8 bits, rather than 32-bit floating point values. If you can
                apply a simple mesh space scale+translation transform to go from this [-1, 1] space
                to the original space of the model, then you can cut your data in half (or less)
                with virtually no impact on visual quality.</para>
            <para>Each section of the code where it uses a mesh space transform happens between a
                    <function>MatrixStack::Push</function> and
                <function>MatrixStack::Pop</function>. This preserves the model space matrix, so
                that it may be used for rendering with other nodes.</para>
            <para>At the bottom of the base drawing function is a call to draw the upper arm. That
                function looks similar to this function: apply the model space matrix to the stack,
                push, apply a mesh space matrix, render, pop, call functions for child parts. All of
                the functions, to one degree or another, look like this. Indeed, they all looks
                similar enough that you could probably abstract this down into a very generalized
                form. And indeed, this is frequently done by scene graphs and the like. The major
                difference between the child functions and the root one is that this function has a
                push/pop wrapper around the entire thing. Though since the root creates a
                MatrixStack to begin with, this could be considered the equivalent.</para>
            <note>
                <para>There are two possible conventions for matrix stack behavior. The caller could
                    be responsible for pushing and popping the matrix, or the callee (the function
                    being called) could be responsible for this. These are called caller-save and
                    callee-save.</para>
                <para>In caller-save, what it is saying is that a function that takes a matrix stack
                    should feel free to do whatever they want to the current matrix, as well as
                    push/pop as much as they want. However, the callee <emphasis>must</emphasis> not
                    pop more than they push, though this is a general requirement with any function
                    taking a matrix stack. After all, a stack doesn't report how many elements it
                    has, so you can't know whether someone pushed anything at all.</para>
                <para>In callee-save, what the convention is saying is that a function must be
                    responsible for any changes it wants to make to the matrix stack. If it wants to
                    change the matrix stack, then it must push first and pop after using those
                    changes.</para>
                <para>Callee-save is probably a better convention to use. With caller-save, a
                    function that takes a matrix stack must be assumed to modify it (if it takes the
                    object as a non-const reference), so it will have to do a push/pop. Whereas with
                    callee-save, you only push/pop as you explicitly need: at the cite where you are
                    modifying the matrix stack. It groups the code together better.</para>
            </note>
        </section>
    </section>
    <section>
        <?dbhtml filename="Tut06 Gimbal Lock.html" ?>
        <title>Gimbal Lock</title>
        <para>Remember back when we said that an rotation matrix isn't a rotation matrix at all,
            that it is an orientation matrix? We also said that forgetting this can come back to
            bite you. Well, here's likely the most common way.</para>
        <para>Normally, when dealing with orienting an object like a plane or spaceship in 3D space,
            you want to orient it based on 3 rotations about the 3 axes. The obvious way to do this
            is with a series of 3 rotations. This means that the program stores 3 angles, and you
            generate a rotation matrix by creating 3 rotation matrices based on these angles and
            concatenating them. Indeed, the 3 angles often have special names, based on common
            flight terminology: yaw, pitch, and roll.</para>
        <para>Pitch is the rotation that raises or lowers the front of the object. Yaw is the
            rotation that turns the object left and right. Roll is the rotation that spins it around
            the direction of motion. These terms neatly duck the question of what the axes
            technically are; they are defined in terms of semantic axes (front, left, direction of
            motion, etc), rather than a specific model space. So in one model space, roll might be a
            rotation about the X axis, but in another, it might be a rotation about the Z
            axis.</para>
        <para>One of the first problems you will note is that the order you apply these rotations
            matter. As stated earlier, a rotation matrix is an <emphasis>orientation</emphasis>
            matrix. Each transform defines a new coordinate system, and the next transform is based
            on an object in the <emphasis>new</emphasis> space. For example, if we apply the roll
            first, we have now changed what the axis for the subsequent yaw is.</para>
        <para>You can use any order that you like, so long as you understand that what these angles
            mean. If you apply the roll first, your yaw and pitch must be in terms of the new roll
            coordinate system, and not the original coordinate system. That is, a change that is
            intended to only affect the roll of the final space may need yaw or pitch changes to
            allow it to have the same apparent orientation (except for the new roll, of
            course).</para>
        <para>But there is a far more insidious problem lurking in here. And this problem happens
            anytime you compute a final rotation from a series of 3 rotations about axes
            perpendicular to each other.</para>
        <para>The tutorial project <phrase role="propername">Gimbal Lock</phrase> illustrates this
            problem. Because the problem was first diagnosed with a device called a <link
                xlink:href="http://en.wikipedia.org/wiki/Gimbal">gimbal</link>, the problem has
            become known as <glossterm>gimbal lock.</glossterm></para>
        <para>A gimbal is a pivoted support that provides the ability to rotate in one axis. A
            gimbal can be mounted within another gimbal. The Gimbal Lock project has a set of 3
            square gimbals, each with a pivot axis that is perpendicular to the other two. This
            effectively mimics the common yaw/pitch/roll angle setup.</para>
        <figure>
            <title>Gimbal Lock Project</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="Three%20Gimbal%20Array.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>You can control the orientation of each gimbal separately. The <keycap>w</keycap> and
                <keycap>s</keycap> keys control the blue gimbal, the <keycap>a</keycap> and
                <keycap>d</keycap> keys control the green gimbal, and the <keycap>q</keycap> and
                <keycap>e</keycap> keys control the red gimbal.</para>
        <para>With these three gimbals, you can cause the innermost gimbal (the red one) to have any
            arbitrary orientation. That isn't the problem. The problem happens when two of the
            gimbals are parallel with one another:</para>
        <figure>
            <title>Parallel Gimbals</title>
            <mediaobject>
                <imageobject>
                    <imagedata fileref="In%20Gimbal%20Lock.png"/>
                </imageobject>
            </mediaobject>
        </figure>
        <para>Now, the purpose of the three gimbals is to be able to adjust one of the three angles
            and orient the object in a particular direction. In a flight-simulation game, the player
            would have controls that would change their yaw, pitch, and roll. However, look at this
            picture.</para>
        <para>The player's theoretical ship is pointed in the direction of the red gimbal. Given the
            controls you have in this project, can you cause the red gimbal to rotate around the
            axis that it is facing? No. You can't even sort of do this. Why?</para>
        <para>Because the blue and red gimbals are now rotating about the <emphasis>same
                axis</emphasis>. Which means you really only have two gimbals to manipulate in order
            to orient the red gimbal. And 3D orientation cannot be fully controlled with only 2
            axial rotations, with only 2 gimbals.</para>
        <para>When gimbals are in such a position, you have what is known as <glossterm>gimbal
                lock</glossterm>; you have locked one of the gimbals to another, and now both cause
            the same effect.</para>
        <para>How do you fix this problem? There are several possible solutions to the
            problem.</para>
        <para>One solution is to simply not use gimbals. After all, if you don't have gimbals, you
            can't gimbal lock. Instead of storing the orientation as a series of rotations, store
            the orientation as an <emphasis>orientation.</emphasis> That is, maintain the current
            orientation as a matrix. When you need to modify the orientation, you apply a
            transformation to this matrix, storing the result as the new current orientation.</para>
        <para>This means that every yaw, pitch, and roll applied to the current orientation will be
            relative to that current orientation.</para>
        <para>A downside of this approach, besides the size penalty of having to store a 4x4 matrix
            rather than 3 floating-point angles, is that floating-point math can lead to errors. If
            you keep accumulating successive transformations of an object, once every 1/30th of a
            second for a period of several minutes, these floating-point errors start accumulating.
            Eventually, the orientation stops being a pure rotation and starts incorporating scale
            and skewing characteristics.</para>
        <para>The solution here is to re-orthonormalize the matrix after applying each transform. A
            transform (space) is said to be <glossterm>orthonormal</glossterm> if the axis vectors
            are of unit length (no scale) and each axis is perpendicular to all of the
            others.</para>
        <para>Unfortunately, re-orthonormalize a matrix is not a simple operation. You could try to
            normalize each of the axis vectors with typical vector normalization, but that wouldn't
            ensure that the matrix was orthonormal. It would remove scaling, but the axes wouldn't
            be guaranteed to be perpendicular.</para>
        <para>The proper solution is to use <link
                xlink:href="http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">unit
                quaternions</link> to store orientations, which can be orthonormalized much more
            easily. This is beyond the scope of this tutorial, but the Wikipedia article on the
            subject is a good place to start.</para>
        <section>
            <title>Complex Mesh Space</title>
            <para>The way this tutorial renders each gimbal serves as an object lesson in the use of
                mesh space. The gimbals are composed of 6 pieces, each of which ultimately derives
                from a simple 3D cube who's sides are of unit length. The cube is scaled and
                translated to form the rectangular prisms used to build each the gimbal.</para>
            <para>The <function>DrawGimbal</function> function takes a matrix stack, an axis (one of
                the three kinds of gimbals), a size for the gimbal, and a color. The width and
                height of a gimbal are the same, so this code only takes a single size.</para>
            <para>There is ultimately only one gimbal <quote>mesh</quote>: the difference between
                them is what their base orientation is. That is computed in this function:</para>
            <example>
                <title>DrawGimbal Function</title>
                <programlisting language="cpp">void DrawGimbal(MatrixStack &amp;currMatrix, GimbalAxis eAxis, float fSize, glm::vec4 baseColor)
{
    currMatrix.Push();
    
    switch(eAxis)
    {
    case GIMBAL_X_AXIS:
        break;
    case GIMBAL_Y_AXIS:
        currMatrix.RotateZ(90.0f);
        currMatrix.RotateX(90.0f);
        break;
    case GIMBAL_Z_AXIS:
        currMatrix.RotateY(90.0f);
        currMatrix.RotateX(90.0f);
        break;
    }
    
    DrawBaseGimbal(currMatrix, fSize, baseColor);
    currMatrix.Pop();
}</programlisting>
            </example>
            <para>The rotation matrices change the orientation of the gimbal to its neutral
                position. These matrices are chosen to allow the full array of 3 gimbals to connect
                properly.</para>
            <para>The <function>DrawBaseGimbal</function> function performs the basic computations
                necessary to draw the pieces. It delegates the actual drawing to other
                functions.</para>
            <example>
                <title>DrawBaseGimbal Function</title>
                <programlisting language="cpp">void DrawBaseGimbal(MatrixStack &amp;currMatrix, float fSize, glm::vec4 baseColor)
{
    //A Gimbal can only be 4 units in size or more.
    assert(fSize > 4.0f);
    
    glUseProgram(theProgram);
    //Set the base color for this object.
    glUniform4fv(baseColorUnif, 1, glm::value_ptr(baseColor));
    glBindVertexArray(vao);
    
    float fGimbalSidesOffset = (fSize / 2.0f) - 1.5f;
    float fGimbalSidesScale = fSize - 2.0f;
    
    DrawGimbalSides(currMatrix, fGimbalSidesOffset, fGimbalSidesScale);
    
    float fGimbalAttachOffset = (fSize / 2.0f) - 0.5f;
    
    DrawGimbalAttachments(currMatrix, fGimbalAttachOffset);
    
    glBindVertexArray(0);
    glUseProgram(0);
}
</programlisting>
            </example>
            <para>The color is stored into a uniform in the program. The fragment shader uses this
                color along with the interpolated per-vertex color to compute the final output
                color.</para>
            <example>
                <title>ColorMultUniform Fragment Shader</title>
                <programlisting language="glsl">#version 330

smooth in vec4 theColor;
uniform vec4 baseColor;

out vec4 outputColor;

void main()
{
    outputColor = theColor * baseColor;
}</programlisting>
            </example>
            <para>The interpolated per-vertex color is multiplied with the base color. The colors
                from the mesh are not really colors in this case; they serve only to darken certain
                faces. The front and back faces use full white (1.0, 1.0, 1.0, 1.0); multiplying
                this by <varname>baseColor</varname> will simply return
                <varname>baseColor</varname>. Thus the front and back faces of the object are the
                intended color. The top and bottom sides use (0.75, 0.75, 0.75, 1.0), which serves
                to make <varname>baseColor</varname> closer to zero, but not by a lot. The left and
                right sides use a smaller value (0.5, 0.5, 0.5, 1.0), which makes the resulting
                color even smaller.</para>
            <para>The <function>DrawBaseGimbal</function> function computes the length and
                positional offset for each of the main pieces of the ring of the gimbal. Since the
                gimbal is square, it only needs a single length and offset. The
                    <function>DrawGimbalSides</function> draws the gimbal's square ring.</para>
            <para>The two attachment points are rendered with ; the sizes for these are fixed, so
                they don't vary with the size of the gimbal. The <emphasis>location</emphasis> of
                these do vary, so <function>DrawBaseGimbal</function> must compute that
                offset.</para>
            <para>All of this code uses multiple spaces in multiple different places. The most
                important thing that it shows is how each layer in the hierarchy of functions
                doesn't care what the space in the matrix stack currently is. DrawBaseGimbal draws
                the gimbal in a certain space; it is up to whatever happens to be on the matrix
                stack as to how it gets transformed into the final space.</para>
            <para>Furthermore, the lower parts of the code don't care about how the gimbal drawing
                gets done. The <function>display</function> function that ultimately calls
                    <function>DrawGimbal</function> doesn't care if it is drawing multiple meshes,
                or a single scaled mesh, or whatever. It simply says to draw the Y-axis gimbal of a
                certain size in a certain color at a transform given by the matrix stack. Similarly,
                    <function>DrawGimbal</function> only expects <function>DrawBaseGimbal</function>
                to draw a X-oriented gimbal; that this requires 6 rendering calls and some matrix
                stack work is not something <function>DrawGimbal</function> is concerned
                with.</para>
            <para>This is the ideal for dealing with complex objects that are positioned via various
                transforms. The higher level code should be insulated from the fact that low level
                code may be performing complex transformations, and low-level code should be
                insulated from the specific uses of that particular object. Look at how simple the
                display function is:</para>
            <example>
                <title>Gimbal Lock's Display Function</title>
                <programlisting language="cpp">void display()
{
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
    glClearDepth(1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    MatrixStack currMatrix;
    currMatrix.Translate(glm::vec3(0.0f, 0.0f, -60.0f));
    currMatrix.RotateX(g_angles.fAngleX);
    DrawGimbal(currMatrix, GIMBAL_X_AXIS, 30.0f, glm::vec4(0.4f, 0.4f, 1.0f, 1.0f));
    currMatrix.RotateY(g_angles.fAngleY);
    DrawGimbal(currMatrix, GIMBAL_Y_AXIS, 26.0f, glm::vec4(0.0f, 1.0f, 0.0f, 1.0f));
    currMatrix.RotateZ(g_angles.fAngleZ);
    DrawGimbal(currMatrix, GIMBAL_Z_AXIS, 22.0f, glm::vec4(1.0f, 0.3f, 0.3f, 1.0f));
    
    glutSwapBuffers();
    glutPostRedisplay();
}</programlisting>
            </example>
            <para>It performs a translation, so that the gimbal is positioned in front of the
                camera. Then it performs the 3 successive rotations, drawing each gimbal after each
                one. So long as <function>DrawGimbal</function> is doing the job that
                    <function>display</function> expects, everything works out fine.</para>
        </section>
    </section>
    <section>
        <?dbhtml filename="Tut06 In Review.html" ?>
        <title>In Review</title>
        <para>In this tutorial, you have learned the following:</para>
        <itemizedlist>
            <listitem>
                <para>Coordinate systems (spaces) are defined by 3 basis axes and a position.</para>
            </listitem>
            <listitem>
                <para>The transformation from one 3D space to another can be defined by a 4x4
                    matrix, which is constructed from the 3 basis axes and the position.</para>
            </listitem>
            <listitem>
                <para>Model space is the coordinate system that a particular model occupies,
                    relative to camera space. Other models can have model spaces that depend on the
                    model space of other models.</para>
            </listitem>
            <listitem>
                <para>Scale, translation, and rotation transformations have specific matrix
                    forms.</para>
            </listitem>
            <listitem>
                <para>Transformations can be composed via matrix multiplication. All transformations
                    for a model can be folded into a single matrix, which a vertex shader can
                    execute at a fixed rate. Therefore, complex transforms are no slower to execute
                    (for the graphics chip) than simple ones.</para>
            </listitem>
            <listitem>
                <para>The order that successive transforms are applied in matters. Matrix
                    multiplication is not commutative, and neither is object transformation.</para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Further Study</title>
            <para>Try doing these things with the given programs.</para>
            <itemizedlist>
                <listitem>
                    <para>In the Translation tutorial, we had two objects that rotated around a
                        specific point. This was achieved by computing the offset for the rotated
                        position on the CPU, not through the use of a rotation transformation.
                        Change this code to use rotation transformations instead. Make sure that the
                        orientation of the objects do not change as they are being rotated around;
                        this will require applying more than one rotation transformation.</para>
                </listitem>
                <listitem>
                    <para>Reverse the order of rotations on the wrist in the Hierarchy tutorial.
                        Note how this affects the ability to adjust the wrist.</para>
                </listitem>
                <listitem>
                    <para>Reimplement the Hierarchy tutorial, instead using a more generic data
                        structure. Have each node be a struct/class that can be attached to an
                        arbitrary node. The scene will simply be the root node. The individual angle
                        values should be stored in the node object. The node should have a render
                        function that will render this node, given the matrix stack. It would render
                        itself, then recursively render its children. The node would also have a way
                        to define the size (in world-space) and origin point of the rectangle to be
                        drawn. The scene would be rendered by passing the identity matrix to the
                        root.</para>
                </listitem>
                <listitem>
                    <para>Given the generalized Hierarchy code, remove the matrix stack. Use objects
                        created on the C++ stack instead. The node render function would take a
                        const&amp; to a matrix rather than a matrix stack reference.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section xml:id="Tut06_Glossary">
        <?dbhtml filename="Tut06 Glossary.html" ?>
        <title>Glossary</title>
        <glosslist>
            <glossentry>
                <glossterm>space, coordinate system</glossterm>
                <glossdef>
                    <para>This defines what the coordinates used to refer to positions actually
                        mean. Coordinate systems have a dimensionality (the number of coordinates),
                        an basis vector for each of the dimensions, and an origin position. A
                        coordinate system of 3 dimensions therefore is defined by 3 vectors and a
                        position. The X, Y and Z coordinates in that coordinate system refer to the
                        value you get when you multiply the X, Y, Z values into the X, Y, and Z
                        axes, then add the origin position to those values.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>basis vector</glossterm>
                <glossdef>
                    <para>One of the vectors that define a coordinate system. The basis vectors of a
                        coordinate system do not have to be orthogonal or of unit length.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>transformation</glossterm>
                <glossdef>
                    <para>The process of moving objects defined in one space to be defined in
                        another space.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>model space</glossterm>
                <glossdef>
                    <para>The space that a particular model is expected to be in, relative to some
                        other space. This can be the camera space, or in hierarchical models, the
                        space of a parent node. This does not have to be the initial space that mesh
                        data is stored in.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>translation transform</glossterm>
                <glossdef>
                    <para>A transform between two spaces, where the origin of the spaces are not in
                        the same location. This causes objects to shift as they are transformed
                        between the two spaces.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>identity matrix</glossterm>
                <glossdef>
                    <para>The matrix I such that the following is true: <inlineequation>
                            <mathphrase>MI = M</mathphrase>
                        </inlineequation>, for any matrix M. Identity matrices only exist for square
                        matrices (a matrix with the same number of columns and rows). An identity
                        matrix consists of a matrix with ones along the diagonal from the top-left
                        to the lower-right, and zeros everywhere else.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>scale transform</glossterm>
                <glossdef>
                    <para>A transform between two spaces where the axis vectors of the source space
                        are longer or shorter than the corresponding axis vectors in the destination
                        space. This causes objects to stretch or shrink along the axes as they are
                        transformed between the two spaces.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>scale inversion</glossterm>
                <glossdef>
                    <para>Performing a scale by a negative value. This is perfectly allowed, though
                        it can change the winding order of triangles, depending on the axis being
                        scaled.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>orthogonal</glossterm>
                <glossdef>
                    <para>Two vectors are orthogonal if they are perpendicular to each other. Three
                        vectors are othogonal if each vector is perpendicular to the other
                        two.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>rotation transform, orientation transform</glossterm>
                <glossdef>
                    <para>A transform between two spaces, where the axis vectors of the two spaces
                        are not pointed in the same direction, but the angle between the axis
                        vectors stay the same. This cause a reorientation of objects as they are
                        transformed from the initial space to the destination space.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>inverse matrix</glossterm>
                <glossdef>
                    <para>The inverse matrix of the matrix M is the matrix B for which the following
                        equation is true: <inlineequation>
                            <mathphrase>MB = I</mathphrase>
                        </inlineequation>, where I is the identity matrix. The inverse of M is
                        usually denoted as M<superscript>-1</superscript>.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>hierarchical model</glossterm>
                <glossdef>
                    <para>Models can be conceptually composed of multiple independent pieces in a
                        hierarchy. The space of each component of that hierarchy is stored relative
                        to its parent in the hierarchy.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>node</glossterm>
                <glossdef>
                    <para>A single model space transform within a hierarchy of model transforms. The
                        node's transform is stored relative to the transform of the node beneath it,
                        called the parent. Nodes can have a single parent node and multiple child
                        nodes; the child nodes' transforms are relative to this node's space.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>mesh space</glossterm>
                <glossdef>
                    <para>A space beyond model space in the sequence of transforms ending in clip
                        space. Mesh space is used to transform from a space that is convenient for
                        storing a mesh in into the model space that the rest of the world
                        uses.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>gimbal lock</glossterm>
                <glossdef>
                    <para>When applying 3 or more successive rotations about axes that are
                        orthogonal to each other, gimbal lock occurs when a degree of rotational
                        freedom is lost due to two or more axes that cause the same effective
                        rotation.</para>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>orthonormal</glossterm>
                <glossdef>
                    <para>A transform has the property of being orthonormal if the three basis axes
                        are all orthogonal and the three axes are normal (have a length of
                        1).</para>
                </glossdef>
            </glossentry>
        </glosslist>
    </section>
</chapter>
