<?xml version="1.0" encoding="UTF-8"?>
<?oxygen RNGSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng" type="xml"?>
<?oxygen SCHSchema="http://docbook.org/xml/5.0/rng/docbookxi.rng"?>
<chapter xmlns="http://docbook.org/ns/docbook" xmlns:xi="http://www.w3.org/2001/XInclude"
    xmlns:xlink="http://www.w3.org/1999/xlink" version="5.0">
    <title>Objects in Motion</title>
    <para>In this tutorial, we will look at a number of ways to transform objects, rendering them in
        different locations and orientations in the world.</para>
    <section>
        <title>Spaces</title>
        <para>Throughout this series of tutorials, we have discussed a number of different spaces.
            We have seen OpenGL-defined spaces like normalized device coordinate (NDC) space,
            clip-space, and window space. And we have seen user-defined spaces like camera space.
            But we have yet to talk about what a space actually is.</para>
        <para>A <glossterm>space</glossterm> is a shorthand term for a <glossterm>coordinate
                system.</glossterm> For the purposes of this conversation, a coordinate system or
            space consists of the following:</para>
        <itemizedlist>
            <listitem>
                <para>The dimensionality of the space. 2D, 3D, 4D, etc.</para>
            </listitem>
            <listitem>
                <para>A series of directions in those dimensions that define the axes of the space.
                    The directions do not have to be orthogonal (at right-angles) to one another,
                    but there must be one axis per dimension. Each axis vector in the space has a
                    name, like X, Y, Z, etc.</para>
            </listitem>
            <listitem>
                <para>A location in the space that defines the central <glossterm>origin</glossterm>
                    point. The origin is the point from which all other points in the space are
                    derived.</para>
            </listitem>
            <listitem>
                <para>An area within this space in which points are valid. Outside of this range,
                    positions are not valid. The range can be infinite depending on the
                    space.</para>
            </listitem>
        </itemizedlist>
        <para>A position or vertex in a space is defined as the sum of the axis vectors, where each
            axis vector is multiplied by a value called a coordinate. Any point in the space is thus
            defined by this equation:</para>
        <!--TODO: Show the vectoral equation defining a point.-->
        <para>The coordinate used to refer to a position depends entirely on the coordinate system
            being used to describe that position. For example, here are two positions that appear
            the same, from a neutral observer's point of view, that have completely different
            coordinates.</para>
        <!--TODO: Show a 2D orthogonal and 2D skewed coordinate system, and the same coordinate position from both.-->
        <para>This is all well and good when dealing with axis vectors and the origin point as
            generic quantities: simple directions from a neutral point of view. But what happens
            when you give them a particular value? What does the value of, for example, the X axis
            vector mean? After all, it is a coordinate, and all coordinates are defined relative to
            some space. So what is the space of the axis vectors or origin points? Or more to the
            point, what is a <quote>neutral point of view?</quote></para>
        <para>There is a coordinate system that acts as an identity coordinate system; it can be
            used as a generic viewpoint for a coordinate system. For a three-dimensional coordinate
            system, this identity space has the origin at (0, 0, 0), with the X, Y and Z axis
            vectors as (1, 0, 0), (0, 1, 0), and (0, 0, 1). The range of the space is infinite. Any
            space can be defined relative to this identity space. And unless otherwise noted, this
            is the space of any axis vectors or origin points.</para>
        <section>
            <title>Transformation</title>
            <para>In the more recent tutorials, the ones dealing with perspective projections, we
                have been taking positions in one coordinate system (space) and putting them in
                another coordinate system. The process of taking a coordinate in one space and
                making it relative to another space is called
                <glossterm>transformation</glossterm>.</para>
            <para>We have seen, and implemented, a number of coordinate system transformations.
                OpenGL implements the transformation from clip-space to NDC space, and the
                transformation from NDC to window space. Our shaders implement the transformation
                from camera space to clip-space, and this was done using a matrix. Perspective
                projection (and orthographic, for that matter) are simply a special kind of
                transformation.</para>
            <para>This tutorial will cover a large number of different kinds of transform
                operations, and how to implement them in OpenGL.</para>
        </section>
        <section>
            <title>Model Space</title>
            <para>Before we begin, we must define a new kind of space: <glossterm>model
                    space.</glossterm> This is a user-defined space; but unlike camera space, model
                space does not have a single definition. It is instead a catch-all term for the
                space that a particular object begins in. Coordinates in vertex buffers, passed to
                the vertex shaders as vertex attributes are <foreignphrase>de facto</foreignphrase>
                in model space.</para>
            <para>There are an infinite variety of model spaces. Each object one intends to render
                can, and often does, have its own model space, even if the difference between these
                spaces is only in the origin point. Model spaces for an object are generally defined
                for the convenience of the modeller or the programmer who intends to use that
                model.</para>
            <para>The transformation operation being discussed in this tutorial is the transform
                from model space to camera space. Our shaders already know how to handle
                camera-space data; all they need is a way to transform from model space to camera
                space.</para>
        </section>
    </section>
    <section>
        <title>Translation</title>
        <para>The simplest space transformation operation is translation. Indeed, we have not only
            seen this transform before, it has been used in all of the tutorials with a perspective
            projection. Remember this line from the vertex shaders:</para>
        <programlisting>vec4 cameraPos = position + vec4(offset.x, offset.y, 0.0, 0.0);</programlisting>
        <para>This is a <glossterm>translation</glossterm> transformation: it is used to position
            the origin point of the initial space relative to the destination space. Since all of
            the coordinates in a space are relative to the origin point of that space, all a
            translation needs to do is add a vector to all of the coordinates in that space. The
            vector added tothese values is the location of where the user wants the origin point
            relative to the destination coordinate system.</para>
        <para>Here is a more concrete example. Let us say that an object which in its model space is
            near its origin. This means that, if we want to see that object in front of the camera,
            we must position the origin of the model in front of the camera. If the extent of the
            model is only [-1, 1] in model space, we can ensure that the object is visible by adding
            this vector to all of the model space coordinates: (0, 0, -3). This puts the origin of
            the model at that position in camera space.</para>
        <!--TODO: 2D diagram of this translation.-->
        <para>Translation is ultimately just that simple. So let's make it needlessly complex. And
            the best tool for doing that: matrices. Oh, we could just use a 3D uniform vector to
            pass an offset to do the transformation. But matrices have hidden benefits we will
            explore... soon.</para>
        <para>All of our position vectors are 4D vectors, with a final W coordinate that is always
            1.0. In <link linkend="Tut04_matrix">Tutorial 04,</link> we took advantage of this with
            our perspective transformation matrix. The equation for the Z coordinate needed an
            additive term, so we put that term in the W column of the transformation matrix. Matrix
            multiplication causes the value in the W column to be multiplied by the W coordinate of
            the vector (which is 1) and added to the sum of the other terms.</para>
        <para>But how do we keep the matrix from doing something to the other terms? We only want
            this matrix to apply an offset to the position. We don't want to have it modify the
            position in some other way.</para>
        <para>This is done by modifying an <glossterm>identity matrix.</glossterm> An identity
            matrix is a matrix that, when performing matrix multiplication, will return the original
            value. It is sort of like the number 1 with regular multiplication: 1*X = X. The 4x4
            identity matrix looks like this:</para>
        <!--TODO: An identity matrix.-->
        <para>To modify the identity matrix into one that is suitable for translation, we simply put
            the offset into the W column of the identity matrix.</para>
        <!--TODO: The translation matrix.-->
        <para>The tutorial project cleverly titled <phrase role="propername">Translation</phrase>
            performs translation operations.</para>
        <para>This tutorial renders 3 of the same object, all in different positions. One of the
            objects is positioned in the center of the screen, and the other two's positions orbit
            it at various speeds.</para>
        <para>Because of the prevalence of matrix math, this is the first tutorial that uses the GLM
            math library. So let's take a look at the shader program initialization code to see it
            in action.</para>
        <example>
            <title>Translation Shader Initialization</title>
            <programlisting>void InitializeProgram()
{
    std::vector&lt;GLuint> shaderList;
    
    shaderList.push_back(Framework::LoadShader(GL_VERTEX_SHADER, "PosColorLocalTransform.vert"));
    shaderList.push_back(Framework::LoadShader(GL_FRAGMENT_SHADER, "ColorPassthrough.frag"));
    
    theProgram = Framework::CreateProgram(shaderList);
    
    positionAttrib = glGetAttribLocation(theProgram, "position");
    colorAttrib = glGetAttribLocation(theProgram, "color");
    
    modelToCameraMatrixUnif = glGetUniformLocation(theProgram, "modelToCameraMatrix");
    cameraToClipMatrixUnif = glGetUniformLocation(theProgram, "cameraToClipMatrix");
    
    float fzNear = 1.0f; float fzFar = 45.0f;
    
    cameraToClipMatrix[0].x = fFrustumScale;
    cameraToClipMatrix[1].y = fFrustumScale;
    cameraToClipMatrix[2].z = (fzFar + fzNear) / (fzNear - fzFar);
    cameraToClipMatrix[2].w = -1.0f;
    cameraToClipMatrix[3].z = (2 * fzFar * fzNear) / (fzNear - fzFar);
    
    glUseProgram(theProgram);
    glUniformMatrix4fv(cameraToClipMatrixUnif, 1, GL_FALSE, glm::value_ptr(cameraToClipMatrix));
    glUseProgram(0);
}</programlisting>
        </example>
        <para>GLM takes a unique approach, for a vector/matrix math library. It attempts to emulate
            GLSL's approach to vector operations where possible. It uses C++ operator overloading to
            effectively emulate GLSL. In most cases, GLM-based code would compile in GLSL.</para>
        <para>The matrix <varname>cameraToClipMatrix</varname> is defined as a
                <type>glm::mat4</type>, which has the same properties as a GLSL <type>mat4.</type>
            Array indexing of a <type>mat4</type>, whether GLM or GLSL, returns the zero-based
                <emphasis>column</emphasis> of the matrix as a <type>vec4</type>.</para>
        <para>The <function>glm::value_ptr</function> function is used to get a direct pointer to
            the matrix data, in column-major order. This is useful for uploading data to OpenGL, as
            shown with the call to <function>glUniformMatrix4fv</function>.</para>
        <para>With the exception of getting a second uniform location (for our model transformation
            matrix), this code functions exactly as it did in previous tutorials.</para>
        <para>There is one important note: <varname>fFrustumScale</varname> is not 1.0 anymore.
            Until now, the relative sizes of objects were not particularly meaningful. Now that we
            are starting to deal with more complex objects that have a particular scale, picking a
            proper field of view for the perspective projection is very important.</para>
        <para>The new <varname>fFrustumScale</varname> is computed with this code:</para>
        <example>
            <title>Frustum Scale Computation</title>
            <programlisting>float CalcFrustumScale(float fFovDeg)
{
    const float degToRad = 3.14159f * 2.0f / 360.0f;
    float fFovRad = fFovDeg * degToRad;
    return 1.0f / tan(fFovRad / 2.0f);
}

const float fFrustumScale = CalcFrustumScale(45.0f);</programlisting>
        </example>
        <para>The function <function>CalcFrustumScale</function> computes the frustum scale based on
            a field-of-view angle in degrees. The field of view in this case is the angle between
            the forward direction and the direction of the farmost-extent of the view.</para>
        <para>This code, and most of those that are part of this section, use a fairly complex bit
            of code to manage the transform matrices for the various object instances. There is an
                <classname>Instance</classname> object for each actual object; it has a function
            pointer that is used to compute the object's offset position. The
                <classname>Instance</classname> object then takes that position and computes a
            transformation matrix, based on the current elapsed time, with this function:</para>
        <example>
            <title>Translation Matrix Generation</title>
            <programlisting>glm::mat4 ConstructMatrix(float fElapsedTime)
{
    glm::mat4 theMat(1.0f);
    
    theMat[3] = glm::vec4(CalcOffset(fElapsedTime), 1.0f);
    
    return theMat;
}</programlisting>
        </example>
        <para>The <type>glm::mat4</type> constructor that takes only a single value constructs what
            is known as a diagonal matrix. That is a matrix with all zeros except for along the
            diagonal from the upper-left to the lower-right. The values along that diagonal will be
            the value passed to the constructor. An identity matrix is just a diagonal matrix with 1
            as the value along the diagonal.</para>
        <para>This function simply replaces the W column of the matrix with the offset value.</para>
    </section>
    <section>
        <title>Scale</title>
        <para>Another kind of transformation is <glossterm>scaling</glossterm>. In terms of our
            previous definition of a coordinate system, this means that our axis vectors are getting
            shorter or longer.</para>
        <!--TODO: show a 2D scaling transform.-->
        <para>Scaling can be uniform, which means each axis vector is scaled by the same value. A
            non-uniform scale means that each axis can get a different scale, or none at all.</para>
        <para>Uniform scales are used to allow objects in model space to have different units from
            the units used in camera space. For example, a modeller may have generated the model in
            inches, but the world uses centimeters. This will require applying a uniform scale to
            all of these models to compensate for this. This scale should be 2.54, which is the
            conversion factor from inches to centimeters.</para>
        <para>Note that scaling always happens relative to the origin of the space being
            scaled.</para>
        <para>Remember how we defined the way coordinate systems generate a position, based on the
            axis vectors and origin point?</para>
        <!--TODO: the vector equation from before-->
        <para>If you are increasing or decreasing the length of the axis vectors, this is the same
            as multiplying those axis vectors by the new length. So we can re-express this equation
            as follows:</para>
        <!--TODO: scaled version of vector equation-->
        <para>Since multiplication is both associative and commutative, we can multiply the scales
            directly into the coordinates to achieve the same effect. So a scaled space can be
            reexpressed as simply multiplying the coordinate values.</para>
        <para>This is easy enough to do in GLSL, if you pass a vector uniform containing the scale
            values. But how do we express this as a matrix?</para>
        <para>This gets a bit technical, in terms of how a matrix multiplication works. But look
            back at the identity matrix:</para>
        <!--TODO: identity matrix again.-->
        <para>This matrix selects each coordinate in turn from the vector it is being multiplied
            into. Each row is multiplied with the column of the vector; all of the zeros remove the
            components of the vector that we do not want. The one multiplies into the component we
            do want, thus selecting it. This produces the identity result: the vector we started
            with.</para>
        <para>We can see that, if the ones were some other value, we would get a scaled version of
            the original vector, depending on which ones were changed. Thus, a scaling
            transformation matrix looks like this:</para>
        <!--TODO: scaling transform matrix.-->
        <para>You may start to see a pattern emerging here, something that begins to suggest why
            matrices are very, very useful. I won't spoil it for you, yet.</para>
        <para>The tutorial project <phrase role="propername">Scale</phrase> will display 5 objects
            at various scales. The objects are all at the same Z distance from the camera, so the
            only size difference between the objects is the scale effects applied to them. The
            object in the center is unscaled; each of the other objects has a scale function of some
            kind applied to them.</para>
        <para>Other than the way the tutorial builds its matrices, there is no difference between
            this tutorial project and the previous one. The matrix building code works as
            follows:</para>
        <programlisting>glm::mat4 ConstructMatrix(float fElapsedTime)
{
    glm::vec3 theScale = CalcScale(fElapsedTime);
    glm::mat4 theMat(1.0f);
    theMat[0].x = theScale.x;
    theMat[1].y = theScale.y;
    theMat[2].z = theScale.z;
    theMat[3] = glm::vec4(offset, 1.0f);
    
    return theMat;
}</programlisting>
        <para>As before, the scale is supplied by a number of scale functions, depending on which
            instance is being rendered. The scale is stored in the columns of the identity matrix.
            Then the translation portion of the matrix is filled in.</para>
        <para>The <varname>offset</varname> variable is also a member of the
                <classname>Instance</classname> object. Unlike the last tutorial, the offset is a
            fixed value. We will discuss the ramifications of applying multiple transforms later;
            suffice it to say, this currently works.</para>
        <para>Scaling is only slightly more complicated than translation.</para>
        <section>
            <title>Inversion</title>
            <para>Scales can be theoretically negative, or even 0. A scale of 0 causes the axis
                vector in that direction to become 0 entirely. An axis vector with no length means
                that a dimension has effectively been lost. The resulting transform squashes
                everthing in that direction down to the origin. A 3D space becomes a 2D space (or 1D
                or 0D, depending on how many axes were scaled).</para>
            <para>A negative scale changes the direction of an axis. This causes vertices
                transformed with this scale to flip across the origin in that axis's direction. This
                is called an <glossterm>inversion</glossterm>. This can have certain unintended
                consequences. In particular, it can change the winding order of vertices.</para>
            <para>Back in <link endterm="tut04_face_culling">Chapter 4</link>, we introduced the
                ability to cull triangles based on the order in which the vertices appeared in
                window space. Depending on which axis you negate, relative to camera space, an
                inversion can flip the expected winding order of vertices. Thus, triangles that
                were, in model space, forward-facing now in camera space are backwards-facing. And
                vice-versa.</para>
            <para>Negative scaling can have other problems as well. This is not to say that
                inversions cannot be used, but they should be used with care.</para>
        </section>
    </section>
    <section>
        <title>Rotation</title>
        <para>A <glossterm>rotation</glossterm> transformation is the result of the orientation of
            the initial space being different from the orientation of the destination space. The
            axis vectors of the space do not changed relative to one another, but relative to the
            destination coordinate system, they are pointed in different directions than they were
            in their own coordinate system.</para>
        <para>A rotation looks like this:</para>
        <!--TODO: Show a rotation transformation-->
        <para>Rotations are usually considered the most complex of transformations, primarily
            because of the math involved in computing the transformation matrix. Generally,
            rotations are looked at as an operation, such as rotating around a particular axis or
            some such. The prior part of the tutorial laid down some of the groundwork that will
            make this much simpler.</para>
        <para>First, let's look back at our equation for determining what the position of a
            coordinate is relative to certain coordinate space:</para>
        <!--TODO: Show the vector equation again-->
        <para>Doesn't this look a bit familiar? No? Perhaps an alternate look at vector-matrix
            multiplication would help:</para>
        <!--TODO: Show a matrix multiplication.-->
        <para>Does it look familiar <emphasis>now</emphasis>?</para>
        <para>What this tells us is that the columns of our transformation matrices are, and have
            always been, nothing more than the axes of a coordinate system. Except for the fourth
            column: because the position has a 1 in the W, it acts as an offset.</para>
        <para>Transformation ultimately means this: taking the axis vectors and origin point from
            the original coordinate system and re-expressing them relative to the destination
            coordinate system.</para>
        <para>Therefore, if a rotation is just using a different set of axis directions, then
            building a rotation transformation matrix simply requires computing a new set of axes
            that different directions, but have the same length as the original ones. Now, this is
            not easy; it requires semi-advanced math (which is easily encapsulated into various
            functions). But no matter how complex the math may be, this is nothing more than a way
            to compute axis vectors that point in different directions.</para>
        <para>That is, a rotation matrix is not really a rotation matrix; it is an
                <emphasis>orientation</emphasis> matrix. It defines the orientation of a space
            relative to another space. Remember this, and you will avoid many pitfalls when you
            start dealing with more complex transformations.</para>
        <para>For any two spaces, the orientation transformation between then can be expressed as
            rotating the source space by some angle around a particular axis (also in the initial
            space). This is true for any change of orientation.</para>
        <para>A common rotation question is to compute a rotation around an arbitrary axis. Or more
            correctly, to determine the orientation of a space if it is rotated around an arbitrary
            axis relative to the initial axis. The axis of rotation is expressed in terms of the
            initial space. In 2D, there is only one axis that can be rotated around and still remain
            within that 2D plane: the Z-axis.</para>
        <!--TODO: show rotation transform.-->
        <para>In 3D, there are many possible axes of rotation. It does not have to be one of the
            initial space's basis axes; it can be any arbitrary direction. Of course, the problem is
            made much simpler if one rotates only around the primary axes.</para>
        <para>Deriving these matrix equations is beyond the scope of this tutorial; so instead, we
            will simply provide them. To perform rotations along the primary axes, use the following
            matrices:</para>
        <!--TODO: show the 3 main rotation matrices.-->
        <para>When using the C library <function>sin</function> and <function>cos</function>
            functions, the angles must be in radians.</para>
        <para>As useful as these are, the more generic equation for rotation by an angle about an
            arbitrary axis is as follows.</para>
        <!--TODO: Show the angle/axis rotation function.-->
        <para>All of these matrices are such that, from the point of view of an observer looking
            down the axis of rotation (the direction of the axis is pointed into the eye of the
            observer), the object rotates counter-clockwise.</para>
        <para>The <phrase role="propername">Rotations</phrase> tutorial shows off each of these
            rotation matrix functions. Similar to how the others work, there are multiple instances
            rendered based on functions. The function that builds the transformation matrix looks
            like this:</para>
        <example>
            <title>Rotation Transformation Building</title>
            <programlisting>glm::mat4 ConstructMatrix(float fElapsedTime)
{
    const glm::mat3 &amp;rotMatrix = CalcRotation(fElapsedTime);
    glm::mat4 theMat(rotMatrix);
    theMat[3] = glm::vec4(offset, 1.0f);
    
    return theMat;
}</programlisting>
        </example>
        <para>The constructor of glm::mat4 that takes a glm::mat3 generates a 4x4 matrix with the
            3x3 matrix in the top-left corner, and all other positions 0 except the bottom-left
            corner, which is set to 1. As with the rest of GLM, this works in GLSL as well.</para>
    </section>
    <section>
        <title>Successive Transformations</title>
        <para>In all of the previous examples except for the translation one, we always combined the
            transformation with a translation operation. So the scale transform was not a pure scale
            transform; it was a scale and translate transformation matrix. The translation was there
            primarily so that we could see everything properly.</para>
        <para>But these are not the only combinations of transformations that can be performed.
            Indeed, any combination of transformation operations is possible, though it may not be
                <emphasis>meaningful.</emphasis></para>
        <para>Successive transformations can be seen as doing successive multiplication operations.
            For example, if S is a pure scale matrix, T is a pure translation matrix, and R is a
            pure scale matrix, then one can easily do the following in a shader:</para>
        <programlisting>vec4 temp;
temp = T * position;
temp = R * temp;
temp = S * temp;
gl_Position = cameraToClipMatrix * temp;</programlisting>
        <para>In mathematical terms, this would be the following series of matrix operations: <inlineequation>
                <mathphrase>Final = C*S*R*T*position</mathphrase>
            </inlineequation>, where C is the camera-to-clip space transformation matrix.</para>
        <!--TODO: show an equation with the various terms.-->
        <para>This is functional, but not particularly flexible; the series of transforms is baked
            into the shader. It is also not particularly fast, what with having to do four matrix
            multiplications, per vertex.</para>
        <para>Matrix math gives us an optimization. Matrix math is not commutative: <inlineequation>
                <mathphrase>S*R</mathphrase>
            </inlineequation> is not the same as <inlineequation>
                <mathphrase>R*S</mathphrase>
            </inlineequation>. However, it <emphasis>is</emphasis> associative: <inlineequation>
                <mathphrase>(S*R)*T</mathphrase>
            </inlineequation> is the same as <inlineequation>
                <mathphrase>S*(R*T)</mathphrase>
            </inlineequation>. The usual grouping for vertex transformation is this: <inlineequation>
                <mathphrase>Final = C*(S*(R*(T*position)))</mathphrase>
            </inlineequation>. But this can easily be regrouped as: <inlineequation>
                <mathphrase>Final = (((C*S)*R)*T)*position</mathphrase>
            </inlineequation>.</para>
        <para>This would in fact be slower for the shader to compute, since full matrix-to-matrix
            multiplication is much slower than matrix-to-vector multiplication. But the combined
            matrix <inlineequation>
                <mathphrase>(((C*S)*R)*T)</mathphrase>
            </inlineequation> is <emphasis>fixed</emphasis> for all of a given object's vertices.
            This can be computed on the CPU, and all we have to do is upload a single matrix to
            OpenGL. And since we're already uploading a matrix to OpenGL for each object we render,
            this changes nothing about the overall performance characteristics of the
            rendering.</para>
        <para><emphasis>This</emphasis> is one of the main reasons matrices are used. You can have a
            transformation sequence with dozens of component transformations, and yet all it takes
            for the GPU to process this is a single vector/matrix multiplication.</para>
        <section>
            <title>Order of Transforms</title>
            <para>As previously stated, matrix multiplication is not commutative. This means that
                the combined transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> is not the same as <inlineequation>
                    <mathphrase>T*S</mathphrase>
                </inlineequation>. Let us explore this further. This is what these two composite
                transform matrices look like:</para>
            <!--TODO: Show T, S, S*T and T*S.-->
            <para>The transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> actually scales the translation part of the resulting matrix. This
                means that the vertices will not just get farther from each other, but farther
                    <emphasis>from the origin</emphasis> of the destination space. It is the
                difference between these two transforms:</para>
            <!--TODO: Show what the two transforms actually look like.-->
            <para>If you think about the order of operations, this makes sense. Even though one can
                think of the combined transform <inlineequation>
                    <mathphrase>S*T</mathphrase>
                </inlineequation> as a single transform, it is ultimately a composite operation. The
                transformation T happens first; the object is translated into a new position.</para>
            <para>What you must understand is that something special happens between S and T.
                Namely, that S is now being applied to positions that are not from model space (the
                space the original vertices were in), but are in <emphasis>post translation
                    space.</emphasis> This is an intermediate coordinate system defined by T.
                Remember: a matrix, even a translation matrix, defines a full-fledged coordinate
                system.</para>
            <para>So S now acts on the T-space position of the vertices. T-space has an origin,
                defined by the matrix T. A scaling transformation matrix performs scaling based on
                the origin point in the space of the vertices being scaled. So the scaling matrix S
                will scale the points away from the origin point in T-space. Since what you
                (probably) actually wanted was to scale the points away from the origin point in
                    <emphasis>model space</emphasis>, S needs to come first.</para>
            <para>Rotation (orientation) matrices have the same issue. The orientation is always
                local to the origin in the current space of the positions. So a rotation matrix must
                happen before the translation matrix. Scales generally should happen before
                orientation; if they happen afterwards, then the scale will be relative to the
                    <emphasis>new</emphasis> axis orientation, not the model-space one. This is fine
                if it is a uniform scale, but a non-uniform scale will be problematic.</para>
            <para>There are reasons to put a translation matrix first. If the model-space origin is
                not the point that you wish to rotate or scale around, then you will need to perform
                the translation first, then apply a scale or rotation. Doing this multiple times can
                allow you to scale and rotate about two completely different points. However, this
                gets progressively more difficult, as each new translation needs to be based on the
                space of the rotated or scaled points.</para>
        </section>
        <section>
            <title>Transformation Spaces</title>
            <para>Our scaling transform is interesting, but it does have certain flaws. The most
                important problem is that it causes a scale based on the X, Y and Z axes of the
                initial coordinate system. So what do you do if you want to scale something along
                different axes?</para>
            <para>This is quite simple, really: you use successive transforms. First, you transform
                into a space where the <quote>different axes</quote>
                <emphasis>are</emphasis> the X, Y and Z axes. Then you do your scaling transform.
                After that, you transform back to the original space.</para>
            <para>If the different axes represent an orientation change, you can use a rotation
                matrix. Simply rotate, apply the scale, and rotate back. The last part is done by
                generating the rotation matrix using the same axis, but negating the angle.</para>
            <para>Transforming into a space that is convenient for another transform, applying that
                transform, and then undoing the first transform is a general-purpose operation. The
                matrix that results from this is a transformation in a different space. In the
                scaling case, we want to do the scaling in a different space, so we apply a rotation
                matrix to get into that space, then undo the rotation after applying the
                scale.</para>
            <para>The general form of this sequence is as follows. Suppose you have a transformation
                T, that you wish to apply in the space M. The transformation matrix T in the space
                of M is <inlineequation>
                    <mathphrase>M<superscript>-1</superscript>TM</mathphrase>
                </inlineequation>.</para>
            <para>The matrix M<superscript>-1</superscript> is the <glossterm>inverse
                    matrix</glossterm> of M. The symbol <superscript>-1</superscript> does not
                (strictly) mean to raise the matrix to the -1 power. It simply means to invert
                it.</para>
            <para>The inverse matrix of M is the matrix N such that <inlineequation>
                    <mathphrase>MN = I</mathphrase>
                </inlineequation>, where I is the identity matrix. This can be analogized to the
                scalar multiplicative inverse (ie: reciprocal). The scalar multiplicative inverse of
                X is the number Y such that <inlineequation>
                    <mathphrase>XY = 1</mathphrase>
                </inlineequation>.</para>
            <para>In the case of the scalar inverse, this is very easy to compute: <inlineequation>
                    <mathphrase>Y = 1/X</mathphrase>
                </inlineequation>. However, even in this case, there are values of X for which there
                is no multiplicative inverse. Well, one value of X: 0.</para>
            <para>The case of the inverse matrix is much more complicated. Just as with the scalar
                inverse, there are matrices that have no inverse. Unlike the scalar case, there are
                a <emphasis>lot</emphasis> of matrices with no inverse. Also, computing the inverse
                matrix is a <emphasis>lot</emphasis> more complicated than simply taking the
                reciprocal of a value.</para>
            <para>Most common transformation matrices <emphasis>do</emphasis> have an inverse. And
                for the simplest of matrices, the inverse matrix is very easy to compute. For a pure
                rotation matrix, simply compute a new rotation matrix by negating the angle that the
                old one was generated with. For a translation matrix, negate the origin value in the
                matrix. For a scale matrix, take the reciprocal of the scale along each axis.</para>
            <para>To take the inverse of a sequence of matrices, you can take the inverse of each of
                the component matrices. But you have to do the matrix multiplication in
                    <emphasis>reverse</emphasis> order. So the inverse matrix for the sequence <inlineequation>
                    <mathphrase>TRS</mathphrase>
                </inlineequation> is <inlineequation>
                    <mathphrase>S<superscript>-1</superscript>R<superscript>-1</superscript>T<superscript>-1</superscript></mathphrase>
                </inlineequation>.</para>
        </section>
        <section>
            <title>Hierarchical Models</title>
            <para>In more complex scenes, it is often desireable to specify the transform of one
                model relative to the model space transform of another model. This is useful if you
                want one object (object B) to pick up another object (object A). The object that
                gets picked up needs to follow the transform of the object that picked it up. So it
                is often easiest to specify the transform for object B relative to object A.</para>
            <para>A conceptually single model that is composed of multiple transforms for multiple
                rendered objects is called a <glossterm>hierarchical model.</glossterm> In such a
                hierarchy, the final transform for any of the component pieces is a sequence of all
                of the transforms of its parent transform, plus its own model space transform.
                Models in this transform have a parent-child relationship to other objects.</para>
            <para>For the purposes of this discussion, each complete transform for a model in the
                hierarchy call be called a <glossterm>node.</glossterm> Each node is defined by a
                specific series of transformations, which when combined yield the complete
                transformation matrix for that node. Usually, each node has a translation, rotation,
                and scale, though the specific transform can be entirely arbitrary. What matters is
                that the full transformation matrix is relative to the space of its parent, not
                camera space.</para>
            <para>So if you have a node who's translation is (3, 0, 4), then it will be 3 X-units
                and 4 Z-units from the origin of its parent transform. The node itself doesn't know
                or care what the parent transform actually is; it simply stores a transform relative
                to that.</para>
            <para>Technically, a node does not have to have a mesh. It is sometimes useful in a
                hierarchical model to have nodes that exist solely to position other, visible nodes.
                Or to act as key points for other purposes, such as identifying the position of the
                gun's muzzle to render a muzzle flash.</para>
            <para>The <phrase role="propername">Hierarchy</phrase> tutorial renders a hierarchical
                model of an arm. This tutorial is interactive; the relative angles of the nodes can
                be changed with keyboard commands. The angles are bound within certain values, so
                the model will stop bending once these values are exceeded. These commands are as
                follows:</para>
            <table frame="none">
                <title>Hierarchy Tutorial Key Commands</title>
                <tgroup cols="3">
                    <colspec colname="c1" colnum="1" colwidth="1.0*"/>
                    <colspec colname="c2" colnum="2" colwidth="1.0*"/>
                    <colspec colname="c3" colnum="3" colwidth="1.0*"/>
                    <thead>
                        <row>
                            <entry>Node Angle</entry>
                            <entry>Increase/Left</entry>
                            <entry>Decrease/Right</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>Base Spin</entry>
                            <entry><keycap>a</keycap></entry>
                            <entry><keycap>d</keycap></entry>
                        </row>
                        <row>
                            <entry>Arm Raise</entry>
                            <entry><keycap>w</keycap></entry>
                            <entry><keycap>s</keycap></entry>
                        </row>
                        <row>
                            <entry>Elbow Raise</entry>
                            <entry><keycap>r</keycap></entry>
                            <entry><keycap>f</keycap></entry>
                        </row>
                        <row>
                            <entry>Wrist Raise</entry>
                            <entry><keycap>t</keycap></entry>
                            <entry><keycap>g</keycap></entry>
                        </row>
                        <row>
                            <entry>Wrist Spin</entry>
                            <entry><keycap>z</keycap></entry>
                            <entry><keycap>c</keycap></entry>
                        </row>
                        <row>
                            <entry>Finger Open/Close</entry>
                            <entry><keycap>q</keycap></entry>
                            <entry><keycap>e</keycap></entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <para>The structure of the tutorial is very interesting and shows off a number of
                important data structures for doing this kind of rendering.</para>
            <para>The class <classname>Hierarchy</classname> stores the information for our
                hierarchy of nodes. It stores the relative positions for each node, as well as angle
                information and size information for the size of each rectangle. The rendering code
                in <function>display</function> simply does the usual setup work and calls
                    <function>Hierarchy::Draw()</function>, where the real work happens.</para>
            <para>The <function>Draw</function> function looks like this:</para>
            <example>
                <title>Hierarchy::Draw</title>
                <programlisting>void Draw()
{
    MatrixStack modelToCameraStack;
    
    glUseProgram(theProgram);
    glBindVertexArray(vao);
    
    modelToCameraStack.Translate(posBase);
    modelToCameraStack.RotateY(angBase);
    
    //Draw left base.
    {
        modelToCameraStack.Push();
        modelToCameraStack.Translate(posBaseLeft);
        modelToCameraStack.Scale(glm::vec3(1.0f, 1.0f, scaleBaseZ));
        glUniformMatrix4fv(modelToCameraMatrixUnif, 1, GL_FALSE, glm::value_ptr(modelToCameraStack.Top()));
        glDrawElements(GL_TRIANGLES, ARRAY_COUNT(indexData), GL_UNSIGNED_SHORT, 0);
        modelToCameraStack.Pop();
    }
    
    //Draw right base.
    {
        modelToCameraStack.Push();
        modelToCameraStack.Translate(posBaseRight);
        modelToCameraStack.Scale(glm::vec3(1.0f, 1.0f, scaleBaseZ));
        glUniformMatrix4fv(modelToCameraMatrixUnif, 1, GL_FALSE, glm::value_ptr(modelToCameraStack.Top()));
        glDrawElements(GL_TRIANGLES, ARRAY_COUNT(indexData), GL_UNSIGNED_SHORT, 0);
        modelToCameraStack.Pop();
    }
    
    //Draw main arm.
    DrawUpperArm(modelToCameraStack);
    
    glBindVertexArray(0);
    glUseProgram(0);
}</programlisting>
            </example>
            <para>The program and VAO binding code should look familiar, but most of the code should
                be fairly foreign.</para>
            <para>The <classname>MatrixStack</classname> object created in the very first line is a
                class that is also a part of this project. It implements the concept of a
                    <glossterm>matrix stack.</glossterm> The matrix stack is a method for dealing
                with transformations in hierarchical models.</para>
            <para>A stack is a particular data structure concept. Stacks store a controlled sequence
                of objects. But unlike arrays, linked lists, or other general data structures, there
                are only 3 operations available to the user of a stack: push, pop, and peek. Push
                places a value on the top of the stack. Pop removes the value on the top of the
                stack, making the previous top the current top. And peek simply returns the current
                value at the top of the stack.</para>
            <para>A matrix stack is, for the most part, a stack where the values are 4x4
                transformation matrices. Matrix stacks do have a few differences from regular
                stacks. C++ has an object, <classname>std::stack</classname>, that implements the
                stack concept. <classname>MatrixStack</classname> is a wrapper around that object,
                providing additional matrix stack functionality.</para>
            <para>A matrix stack has a current matrix value. An initially constructed matrix stack
                has an identity matrix. There are a number of functions on the matrix stack that
                multiply the current matrix by a particular transformation matrix; the result
                becomes the new current matrix. For example, the
                    <classname>MatrixStack::RotateX</classname> function multiplies the current
                matrix by a rotation around the X axis by the given angle.</para>
            <para>The <function>MatrixStack::Push</function> function takes the current matrix and
                pushes it onto the stack. The <function>MatrixStack::Pop</function> function makes
                the current matrix whatever the top of the stack is, and removes the top from the
                stack. The effect of these is to allow you to save a matrix, modify the current
                matrix, and then restore the old one after you have finished with the modified one.
                This is invaluable when dealing with a hierarchical model, as it allows you to
                iterate over each element in the model from root to the leaf nodes, preserving older
                transforms and recovering them as needed.</para>
            <para>In the <function>Draw</function> code, the translation is applied to the stack
                first, followed by an X rotation based on the current angle. Note that the order of
                operations is <emphasis>backwards</emphasis> from what we said previously. That's
                because the matrix stack looks at transforms backwards. When we said earlier that
                the rotation should be applied before the translation, that was with respect to the
                    <emphasis>position</emphasis>. That is, the equation should be <inlineequation>
                    <mathphrase>T*R*v</mathphrase>
                </inlineequation>, where v is the position. What we meant was that R should be
                applied to v before T. This means that R comes to the right of T.</para>
            <para>Rather than applying matrices to vertices, we are applying matrices to each other.
                The matrix stack functions all perform right-multiplication; the new matrix being
                multiplied by the current is on the right side. The matrix stack starts with the
                identity matrix. To have it store T*R, you must first apply the T transform (the
                current matrix is I*T) then apply the R transform, making the current matrix
                I*T*R.</para>
            <para>Right-multiplication is necessary, as the whole point of using the matrix stack is
                so that we can start at the root of a hierarchical model and save each node's
                transform to the stack as we go from parent to child. That simply would not be
                possible if matrix stacks left-multiplied, since we would have to apply the child
                transforms before the parent ones.</para>
            <para>The next thing that happens is that the matrix is preserved by pushing it on the
                stack. After this, a translation and scale are applied to the matrix stack. The
                stack's current matrix is uploaded to the program, and a model is rendered. Then the
                matrix stack is popped, restoring the original transform. What is the purpose of
                this code?</para>
            <para>This code effectively introduces a new kind of space. It was not strictly
                necessary for this example, but it does show off a commonly used technique. The new
                space here does not have a widely agreed upon name, the way other user-defined
                spaces like model space and camera space do. For the purposes of these tutorials,
                let us call this <glossterm>mesh space.</glossterm></para>
            <para>Notice that, for the individual nodes of hierarchical models, model space (the
                node's transform) is propagated to all of the children. The T*R matrix we generated
                was the model space matrix for the base of the model; this transform is preserved on
                the matrix stack and passed to the child drawing functions. However, sometimes it is
                useful to use source mesh data where the mesh itself is <emphasis>not</emphasis> in
                model space.</para>
            <para>In our case, we do this because we know that all of our pieces are 3D rectangles.
                A 3D rectangle is really just a cube with scales and translations applied to them.
                The scale makes the cube into the proper size, and the translation positions the
                origin point for our model space.</para>
            <para>Rather than have this mesh space transform, we could have created 9 or so actual
                rectangle meshes, one for each rendered rectangle. However, this would have required
                more buffer object room and more vertex attribute changes when these were simply
                unnecessary. The vertex shader runs no slower this way; it's still just multiplying
                by matrices. And the minor CPU computation time is exactly that: minor.</para>
            <para>Mesh space is very useful, even though it isn't commonly talked about to the point
                where it gets a special name. Even when not reusing the same model like this, it can
                be good for data compression. There are ways to store values on the range [0, 1] or
                [-1, 1] in 16 or 8 bits, rather than 32-bit floating point values. If you can apply
                a simple mesh space scale+translation transform to go from this [-1, 1] space to the
                original space of the model, then you can cut your data in half (or less) with a
                minimal precision loss.</para>
            <para>Each section of the code where it uses a mesh space transform happens between a
                    <function>MatrixStack::Push</function> and
                <function>MatrixStack::Pop</function>.</para>
            <para>At the bottom of the base drawing function is a call to draw the upper arm. That
                function looks similar to this function: apply the model space matrix to the stack,
                push, apply the mesh space matrix, render, pop, call functions for child parts. All
                of the functions, to one degree or another, look like this. Indeed, they all looks
                similar enough that you could probably abstract this down into a very generalized
                form. And indeed, this is frequently done by scene graphs and the like. The major
                difference between the child functions and the root one is that this function has a
                push/pop wrapper around the entire thing. Though since the root creates a
                MatrixStack to begin with, this could be considered the equivalent.</para>
            <note>
                <para>There are two possible conventions for matrix stack behavior. The caller could
                    be responsible for pushing and popping the matrix, or the callee (the function
                    being called) could be responsible for this. These are called caller-save and
                    callee-save.</para>
                <para>In caller-save, what it is saying is that a function that takes a matrix stack
                    should feel free to do whatever they want to the current matrix, as well as
                    push/pop as much as they want. However, the callee <emphasis>must</emphasis> not
                    pop more than they push, though this is a general requirement with any function
                    taking a matrix stack. After all, a stack doesn't report how many elements it
                    has, so you can't know whether someone pushed anything at all.</para>
                <para>In callee-save, what the convention is saying is that a function must be
                    responsible for any changes it wants to make to the matrix stack. If it wants to
                    change the matrix stack, then it must push first and pop after using those
                    changes.</para>
                <para>Callee-save is probably a better convention to use. With caller-save, a
                    function that takes a matrix stack must be assumed to modify it (if it takes the
                    object as a non-const reference), so it will have to do a push/pop. Whereas with
                    callee-save, you only push/pop as you explicitly need: at the cite where you are
                    modifying the matrix stack. It groups the code together better.</para>
            </note>
        </section>
    </section>
    <section>
        <title>Gimbal Lock</title>
        <para/>
    </section>
    <section>
        <title>In Review</title>
        <para/>
        <section>
            <title>Further Study</title>
            <para>Try doing these things with the given programs.</para>
            <itemizedlist>
                <listitem>
                    <para>In the Translation tutorial, we had two objects that rotated around a
                        specific point. This was achieved by computing the offset for the rotated
                        position on the CPU, not through the use of a rotation transformation.
                        Change this code to use rotation transformations instead. Make sure that the
                        orientation of the objects do not change as they are being rotated; this
                        will require using more than one rotation transformation.</para>
                </listitem>
                <listitem>
                    <para>Reverse the order of rotations on the wrist in the Hierarchy tutorial.
                        Note how this affects the ability to adjust the wrist.</para>
                </listitem>
                <listitem>
                    <para>Reimplement the Hierarchy tutorial, instead using a more generic data
                        structure. Have each node be a struct/class that can be attached to an
                        arbitrary node. The scene will simply be the root node. The individual angle
                        values should be stored in the node object. The node should have a render
                        function that will render this node, given the matrix stack. It would render
                        itself, then recursively render its children. The node would also have a way
                        to define the size (in world-space) and origin point of the rectangle to be
                        drawn. The scene would be rendered by passing the identity matrix to the
                        root.</para>
                </listitem>
                <listitem>
                    <para>Given the above code, remove the matrix stack. Use objects created on the
                        C++ stack instead. The node render function would take a const&amp; to a
                        matrix rather than a matrix stack reference.</para>
                </listitem>
            </itemizedlist>
        </section>
    </section>
    <section>
        <title>Glossary</title>
        <glosslist>
            <glossentry>
                <glossterm>space, coordinate system</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>transformation</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>model space</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>translation transform</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>identity matrix</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>scale transform</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>inversion</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>orthogonal</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>rotation transform</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>inverse matrix</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>hierarchical model</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>node</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
            <glossentry>
                <glossterm>mesh space</glossterm>
                <glossdef>
                    <para/>
                </glossdef>
            </glossentry>
        </glosslist>
    </section>
</chapter>
